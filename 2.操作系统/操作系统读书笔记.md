# 0.规划

两天一章，预计5月底读完

5.11目前第二章读一三分之一

一天最多20页。



时间：2023.05.07~05.26（20天左右）

内容：进程管理（2章）、内存管理（2章）、输入输出管理（1章）、文件管理（1章）、磁盘存储器管理（1章）

帮助理解OS是如何管理和分配计算机硬件资源。

总结：

进程管理：进程控制、进程同步、进程通信、进程调度

内存管理：内存分配、内存保护、地址映射、虚拟内存

设备管理：IO操作处理（中断程序和驱动程序）、设备分配（设备独立性软件）、缓冲区管理

文件管理：文件存储空间管理（文件逻辑结构、物理结构、磁盘管理）、目录管理、读写保护（文件共享、文件保护）

# 第一章 操作系统引论

## 操作系统的目标和作用

**作用：**

**1.OS作为用户与硬件资源之间的接口：**用户可以通过命令方式、系统调用和图标-窗口方式与OS通信进而操作硬件。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\1-1-1.png" alt="image-20230507090828911" style="zoom:80%;" />

**2.OS作为计算机系统资源的管理者：**计算机系统资源包括处理机、存储器、IO设备和文件（数据和程序）

**3.OS实现对于计算机资源的抽象：**比如IO软件实现对于IO硬件的抽象，向上提供read和write操作；进一步使用文件管理系统进行抽象，使用文件系统提供的读写命令（这些读写命令会调用下层的IO软件提供的read和write命令使用IO设备）。因此OS可以看作是一系列对于硬件进行抽象的软件集合。

## 操作系统发展

**1.未配置操作系统的计算机系统：**1945年到50年代中期的第一代计算机。

（1）人工操作方式：即将程序和数据整理在穿孔的纸带上。缺点：用户独占整机以及资源利用率低（CPU等待人工操作）

（2）脱机输入输出：首相将程序和数据通过外围机输入到磁带上，然后CPU与磁带（磁带调入内存或者内存写入磁带）进行数据交换，最后通过外围机将磁带信息读取。优点：减少CPU空闲时间；提高IO速度。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\1-2-1.png" alt="image-20230507091852216" style="zoom:67%;" />

**2.单道批处理系统：**50年代第二代晶体管计算机。

内存中只能有一个程序：设置一个监督程序，不断将外存中的作业调入内存，然后控制权交给作业，作业完成之后将控制权交给监督程序。

缺点：CPU会在单道程序（内存中的程序）进行IO操作时处于空闲状态。

**多道批处理系统：**60年代中期第三代小规模集成电路。

由作业调度程序从外存中的若干个作业队列中选择几个作业进入内存，然后利用作业A进行IO操作的时间让CPU对作业B进行处理。

优点：提高了资源利用率。

缺点：作业的平均周转时间长（因为多个作业轮流执行）

**在这个时期出现OS定义：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。**
**3.分时系统：**人机交互与共享主机

（1）及时接收多个用户输入：通过轮流扫描输入端口完成。

（2）及时处理：多个用户的作业都在内存中（才能运行和被处理）；每个用户的作业轮转运行一个时间片

**4.实时系统：**及时相应外部请求，并在规定时间内完成

**5.微机操作系统：**单用户单任务（用户的程序作为一个任务处理，比如MS-DOS）、单用户多任务（将用户程序作为多个任务，方便并发执行，比如Windows）、多用户多任务（多个用户共享主机资源，每个用户的程序分为多个任务，比如UNIX和Linux）

## 操作系统基本特性

**1.并发**

并行指的是在同一时刻发生，并发指的是在同一个时间段发生。例如在宏观上1s内运行ABCD四个程序，属于并行；在单处理机下微观下是0\~25ms运行A、25\~50运行程序B...属于并发。

进程的概念：比如一个程序由计算部分和IO部分，可以分别为二者设置一个进程，计算进程与IO进行可以并发执行。

进行指的就是在系统中能够独立运行并作为资源分配的基本单位，由一组机器指令、数据和堆栈组成，是一个独立运行的活动实体。

**2.共享**

资源共享或者资源复用，指的是系统资源可供内存中的多个并发进程共同使用。时间是进程在内存中时，地点是内存。

（1）互斥共享：一段时间内只允许一个进程访问的资源（临界资源），一个进程使用完另一个进程才能使用的共享方式。

（2）同时访问：微观意义上是交替访问，宏观意义上是同时访问。

**3.虚拟**

将·一个·物理实体看作是逻辑上若干个实体。

（1）时分复用：利用空闲时间去为另一个用户服务。虚拟处理机技术：多道程序设计技术使得每个用户都感觉处理机在为自己服务。虚拟设备技术：允许每个用户占用一个逻辑上的IO设备，但是实际上只有一个设备在为并发多道程序提供服务。

（2）空分复用：利用空闲存储空间提供给其他用户以及虚拟存储技术，当部分子程序用完之后调出内存，运行另一部分子程序。

如果是时分复用，那么逻辑上的每台处理机的速度是物理上单台处理机的1/N；空分复用，空分复用同理。

**4.异步**

由于并发和进程的引入，进程是以不可预知的速度前进。

## 操作系统功能

**处理机管理：**在传统的多道程序系统中，处理的分配和运行都是以进程为单位，所以处理机管理就是对于进程的管理

1.进程控制：进程的创建撤撤销

2.进程同步：为了协调多个进程的并发执行。

（1）进程互斥：访问临界资源时，常用方式为为一个临界资源设置锁，锁关上不允许进程访问，锁开时才能被访问。

（2）进程同步：相互合作完成共同任务的多个进程之间的次序进行协调，常用方式为信号量机制。

3.进程通信：进程之间交换信息，通常是将消息挂在进程的消息队列中，进程使用接收命令获得消息。

4.进程调度：

（1）作业调度：将作业从外存中调入内存，创建进程；

（2）进程调度：选择进程分配处理机。

**存储器管理：**

1.内存分配：为程序分配内存空间，包括静态（作业进入内存之后内存位置和大小不允许变化）和动态（于静态相反）。

2.内存保护：程序只能运行在被分配的内存空间，不允许访问操作系统的程序和数据以及其它程序的内存和数据。

3.地址映射：程序经过编译之后程序地址都是从0开始，因此在执行时需要将逻辑地址转化为物理地址。

4.内存扩充：采用虚拟存储技术使得逻辑内存扩充。

（1）请求调入：当程序需要的数据不在内存中时，需要向OS请求调入数据和程序

（2）置换：将内存中不需要的程序和数据换出，将需要的程序和数据调入。

**设备管理功能：**分配IO设备和提高CPU利用率

1.缓冲管理：为了解决CPU和IO速度不匹配，设置缓冲区。

2.设备分配：选择使用的IO设备。

3.设备处理：使用IO。

**文件管理：**

1.存储空间的管理

2.目录管理

3.读写保护

**操作系统和用户之间的接口：**

1.用户接口：联机用户接口、脱机用户接口和图形用户接口

2.程序接口：就是一组系统调用，每一个系统调用都能完成特定功能。

## OS结构设计

**传统的OS结构：**

无结构操作系统->模块化结构OS->分层式结构OS

模块化：每个模块有自己的功能

分层式：由于模块化的设计并没有顺序的概念，即一般的设计是自顶向下或者自底向上，总之就是上层要用到下层的功能，要先实现下层的基本功能再实现上层的功能。所以引入了分层式结构。

**客户-服务器模式**

**面向对象**

**微内核OS结构：将操作系统划分为两大部分——微内核和多个服务器**

微内核是最基本的、最贴近硬件的功能作为内核。

操作系统的绝大部分功能作为服务器，客户进程需要通过微内核与服务器进程交互。

# 第二章 进程的描述与控制

主要介绍了进程控制、进程同步、进程通信和线程的概念。

加深了程序在内存中是如何运行的概念。

## 前驱图和进程执行

**前驱图**就是使用点和箭头表示程序执行的顺序，只有当前驱进程执行完成后续的进程才能够执行。（前驱图中不能够有循环。）

**程序执行方式**分为顺序执行和并发执行：

**顺序执行：**前一个程序段运行结束之后才能执行下一个程序段。**特点：**1.顺序性；2.封闭性（程序段运行时独占全机资源，因此不受外界影响）；3.可再现性。

**并发执行**：不存在前驱关系的进程（程序段）能够并发执行。**特点：**1.间断性（并发执行的进程之前形成了相互制约的关系，比如我等你，你等我，因此进程运行总是执行-间断-执行）；2.失去封闭性（由于内存中存在多个并发进程，它们会共享系统资源，因此彼此影响，不再封闭）；3.不可再现性（失去了封闭，受到互相影响，执行结果也不可复现）。

## 进程的描述

**进程实体**可以看作是程序段、数据段、PCB三个部分组成。

**PCB进程控制块**是一个数据结构，描述了进程的信息，便于控制和管理进程。

（各类资源抽象为各种数据结构，以及对这组资源进行操作的命令：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-2-3.png" alt="image-20230512092213622" style="zoom:67%;" />

进程控制块的作用：

1.作为独立运行的标志；

2.实现间断性运行（因为PCB中记录了进程的主要信息，当需要被中断执行时，讲CPU信息保存在PCB中，方便以后恢复）；

3.提供进程管理需要的信息；

4.提供进程调度需要的信息；

5.实现进程同步和进程通信。

进程控制块中的信息：

1.进程标识符；2.处理机状态；3.进程调度信息（进程状态、优先级等等）；4.进程控制信息（程序和数据的地址、进程同步和通信机制等等）

进程控制块组织方式：

1.线性方式；2.链式方式：根据状态建立不同的队列

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-2-4.png" alt="image-20230512092803425" style="zoom:67%;" />

3.索引方式：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-2-5.png" alt="image-20230512092839933" style="zoom:67%;" />



**进程**是进程实体的一个运行过程，具有一定的系统资源（比如用于存放程序、数据的内存和磁盘空间，以及要访问的IO设备、打开的文件等等），并且能够被独立调度。

**进程的特征：**1.动态性（指的是这是一个执行过程，而程序只是一段指令集合）；2.并发性（多个进程同时存在于内存中，在一段时间内能够同时运行）；3.独立性；4.异步性。

**进程的基本状态：**

就绪状态：其它资源已经分配完毕，只差分配处理机。

执行状态：分配处理机执行。

阻塞状态：暂时无法执行（比如IO请求）

创建状态：尚未进入内存。

终止状态：保存剩余一些信息，不再执行。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-2-1.png" alt="image-20230512091630039" style="zoom:80%;" />

**挂起状态的引入：**

挂起是调到外存。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-2-2.png" alt="image-20230512091955279" style="zoom:80%;" />



## 进程控制

**OS内核：常驻内存的核心程序段。**

将处理机的执行状态分为系统态（管态）：能够执行一切指令和范围跟所有寄存器以及存储区；用户态（目态）：指定的指令和指定的寄存器以及存储区。

应用程序一般只能在用户态运行，不可执行OS指令和访问OS区域。

内核的基本功能：支撑功能（中断、时钟管理、原语操作即若干条指令要么全都执行要么全不执行）和资源管理（进程管理、设备管理、内存管理）

**进程的创建与终止**

**进程的阻塞与唤醒：注意阻塞是主动行为，唤醒是被动行为。**

**进程的挂起与激活：激活是从外存调入内存。**

（详细去看书的描述过程）

## 进程同步

目的是协调多个进程之间的工作顺序，按照一定的规则共享系统资源，使得具有可再现性。

**进程之前存在的制约关系**：间接制约关系（因为都需要访问临界资源而发生冲突）和直接制约关系（因为彼此之间需要合作，比如写完才能读这种关系而冲突）

**临界资源指的是一段时间内只能由一个进程访问和使用。**

进程划分为多个区域：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-2-6.png" alt="image-20230512094351281" style="zoom:67%;" />

在进入区判断能够使用临界资源，在退出区释放临界资源。

**同步机制应该遵循的规则：**

1.空闲让进；2.忙则等待；3.有限等待；4.让权等待

**硬件同步机制：**

1.关中断：就是在进入临界区执行期间，关闭中断，这样CPU就不会响应其它进程的请求而发生进程切换。

2.TS指令：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-1.png" alt="image-20230512094636947" style="zoom:67%;" />

lock初始值为false，表示无进程使用，一个进程在进入区不断调用TS指令，如果正在使用则会一直等待，只有当lock为false是才能占用，并设置为true。

3.swap指令：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-2.png" alt="image-20230512094819118" style="zoom:67%;" />

对于一个进程：局部变量获取全全局变量lock的值，如果是false则可以使用。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-3.png" alt="image-20230512094842831" style="zoom:67%;" />

**信号量机制：**

由于硬件同步机制都不符合"让权等待"的原则，所以会降低系统运行效率。

1.整型信号量：S表示资源数目

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-4.png" alt="image-20230512095100777" style="zoom:67%;" />

2.记录型信号量：主要是因为整型信号量也是一直循环测试等待，不符合”让权等待“原则。这里不仅用value表示资源数目，而且增加一个链表表示等待这个资源的进程。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-5.png" alt="image-20230512095254292" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-6.png" alt="image-20230512095310679" style="zoom:67%;" />

wait操作：先value减一，表示有一个进程需要这个资源。当value小于0时，表示资源数目不够，因此挂起这个进程。当value为负数时，value的绝对值表示挂起的进程数目。

signal操作：首先释放一个资源，如果释放之后还不大于1，说明挂起队列不为0，应该挑选一个分配资源。

3.AND型信号量：就是一次分配所有需要的不同类型的资源。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-7.png" alt="image-20230512095705985" style="zoom: 67%;" />

4.信号量集：对于资源有一个最低限度值，剩余资源不能小于这个临界值，Swait(S, t, d)表示分配出去的资源d，不能使得S的资源数据小于t。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-8.png" alt="image-20230512095852560" style="zoom:67%;" />

**信号量实现进程互斥和前驱关系：**

进程互斥：在进入临界区之前wait，之后signal

实现前驱：设置一个公用信号量初始值为0，只有当前驱执行外才进行signal操作（使其增1），在后继执行前需要wait这个信号量。

**管程机制：**

管程就是一个抽象数据结构，表示这组共享资源以及操作。

每次只允许一个进程使用管程，从而实现了进程互斥。

条件变量的引入：比如一个进程调用了管程，但是该进程阻塞了，那么在阻塞的整个期间别的进程都无法使用管程。因此引入条件变量，表示引起阻塞的原因，每个条件变量对应着一个链表，挂者因为这个条件变量阻塞的进程。提供两个操作：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-3-9.png" alt="image-20230512100448990" style="zoom:67%;" />

## 进程通信

进程通信指的是进程之间的信息交换。

**进程通信机制：**

1.共享存储器系统：分为共享数据结构（比如生产者消费者中的共享缓冲区）和共享存取区（即在内存中划分一块区域，两个进程进行读写）。

2.管道系统：对一个共享文件即pipe文件进行读写。

3.消息传递系统：直接通信方式（通过发送和接收原语发送和接收消息）和间接通信方式（共享中间实体）

4.客户-服务机系统：

（1）套接字：一个套接字就是一个数据结构，包含了通信目的地址、使用的端口号、传输层协议等等。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-4-1.png" alt="image-20230512160849887" style="zoom:67%;" />

2.远程过程调用和远程方法调用：RPC

<img src="D:\RegularFile\CSLearning\2.操作系统\image\2-4-2.png" alt="image-20230512161033083" style="zoom:67%;" />

引入存根（stub）概念之后的远程过程调用具体步骤看书。

**消息传递系统的实现**

## 线程的基本概念

引入进程是为了实现程序的并发执行，提高资源利用率；

引入线程是为了减少并发切换的时空开销，使得具有更好的并发性。

主要是因为进程的创建、切换、销毁是具有开销的。

引入线程之后：进程仍是拥有资源的基本单位，但是线程是独立运行和调度的基本单位。

线程也是通过TCB控制。

## 线程的实现

1.内核支持线程（KST）

在内核空间为每一个线程创建一个TCB，由内核为TCB提供服务。

主要缺点是用户程序一般都运行在用户态，当需要线程调度和管理时，需要进入内核态进行操作，系统开销大。

2.用户级线程（ULT）

用户及线程与内核无关，因此在内核看来还是以进程方式进行调度和管理。

3.组合方式：把用户级线程映射到内核级线程。

**具体实现：**

1.内核级：就是在内核里创建TCB进行管理

2.用户级分为运行时系统和内核控制线程。

运行时系统是用于管理和控制线程的函数的集合，用户级线程通过将要求传递给运行时系统进而完成系统调用。

内核控制线程：系统中存在一些轻型进程LWP，可以直接进行系统调用，所以可以将用户级线程连接到LWP上，方便进行系统调用。

# 第三章 处理机调度与死锁

## 处理机调度的层次和调度算法的目标

处理机调度主要是为了为了将处理机资源分配给作业或者进程，让其能够运行，并且使得处理机资源得到合理的运用。

**处理机调度的层次：**

1.作业调度（高级调度）：主要是讲作业从外存后备队列调入内存，为其创建进程、分配资源。（批处理系统需要，但是在分时和实时系统中由于用户进程都是常驻内存，所以通常不设置，但是有时会限制内存中的用户进程数目）

2.进程调度（低级调度）：主要是对于内存中的进程来说，选择一个进程让给它分配处理机资源。

3.内存调度（中级调度）：将目前不能运行的进程调至外存等待，称为挂起状态，实际上是存储器管理中的对换功能。

**处理机调度的目标：**

1.处理机调度算法的共同目标：（1）资源利用率，即CPU有效工作时间/有效工作时间 + 等待时间；（2）公平性：各个进程应该获取合理的CPU时间；（3）平衡性：使得计算型和IO型进程对于CPU内部和IO设备都能处于忙碌状态；

2.批处理系统目标：平均周转时间短：周转时间指的是从作业提交给系统开始，指导作业完成为止，包括在外存上时间、在内存等待时间、在CPU上运行时间、等待IO操作时间。

...

## 作业调度

作业调度三个阶段:

1.收容阶段：将作业输入到硬盘上，为其创建JCB；

2.运行阶段：当作业被作业调度程序选中直到完成；

3.完成阶段

**调度算法：**

1.先来先服务算法（FCFS）：根据到达时间优先。

2.短作业优先（SJF）：运行时间短的作业优先。

3.优先级调度算法和高相应比优先调度算法（HRRN，Highest Response Ratio Fisrt）：根据优先级进行选中。响应比指的是：（等待时间+服务时间）/服务时间

以上即可用于作业调度也可用于进程调度。

## 进程调度

**进程调度的主要任务：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-3-1.png" alt="image-20230513100229670" style="zoom: 80%;" />

**进程调度的机制：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-3-2.png" alt="image-20230513100308785" style="zoom:80%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-3-3.png" alt="image-20230513100328881" style="zoom:80%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-3-4.png" alt="image-20230513100424340" style="zoom:80%;" />

**进程调度方式可以分为抢占式和非抢占式。**

**1.轮转调度算法（RR，Round Robin）：每个进程运行一个时间片。**

**2.优先级调度算法：根据优先级选定一个进程之后就让它一直运行下去。**由抢占和非抢占式。优先级分为静态优先级和动态优先级。

**3.多队列调度算法：**将系统中的进程从一个就绪队列分成多个，不同的就绪队列采用不同的调度算法。针对于多处理机系统。

**4.多级反馈队列调度算法：**1.设置多个就绪队列，优先级越高的队列时间片越小；2.每个队列都采用FCFS和RR调度算法，即每个进程运行一个时间片，如果完成就调出到下一个优先级队列；3.按照优先级调度：先分给优先级高的队列使用；并且如果优先级队列高的增加了进程，那么也是优先级高的运行，正在运行的放回本队列队尾。

5.基于公平的优先级调度：（1）保证每个进程使用CPU的时间都差不多；（2）对于拥有不同进程数的用户，应该设置各自分配给每个用户的运行时间，而不是针对进程分配。、

## 实时调度

实现实时调度需要的一些条件：

1.系统需要向调度程序提供必要信息：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-1.png" alt="image-20230513150319178" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-2.png" alt="image-20230513150346123" style="zoom:67%;" />

2.系统的处理能力强：

如果是单处理器，设单处理器的处理硬实时任务的时间为C，HRT的周期为P，那么要求：$\sum_{i=1}^m{\frac{C_i}{P_i}\le 1}$

如果是多处理器N个，那么1就需要换成N。

3.采用抢占式调度

4.具有快速切换机制

**实时调度算法的分类：**

1.非抢占式调度算法：非抢占式轮转调度算法（运行完一个时间片之后挂在轮转队列末尾）和非抢占式优先调度算法

2.抢占式调度算法：基于时钟中断和立即抢占

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-3.png" alt="image-20230513151024670" style="zoom:67%;" />

**1.最早截止时间优先（EDF）算法：**

根据任务的截止时间缺点优先级，如果截止时间越早，优先级越高。

（1）非抢占式调度方式用于非周期实时任务

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-4.png" alt="image-20230513151222565" style="zoom:67%;" />

（2）抢占式调度方式用于周期实时任务

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-5.png" alt="image-20230513151300618" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-6.png" alt="image-20230513151321753" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-7.png" alt="image-20230513151402201" style="zoom:67%;" />

**2.最低松弛度优先算法（LLF）**

松弛度：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-8.png" alt="image-20230513151513665" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-9.png" alt="image-20230513151551591" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-10.png" alt="image-20230513151619067" style="zoom:67%;" />

**3.优先级倒置**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-11.png" alt="image-20230513151703414" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-12.png" alt="image-20230513151725669" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-13.png" alt="image-20230513151755102" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-4-14.png" alt="image-20230513151810116" style="zoom:67%;" />

## 死锁概述

**系统中资源分类：**能够引起死锁的主要是系统中需要互斥访问的、不可抢占的资源，即临界资源。

1.可重用性资源（可供用户重复使用的资源）和消耗性资源（由进程动态创建和消耗）

2.可抢占性资源和不可抢占性资源。

**计算机中的死锁：**

1.因竞争不可抢占性资源引起死锁；2.因竞争可消耗资源引起死锁；3.进程推进顺序不当引起死锁

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-1.png" alt="image-20230515215454910" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-2.png" alt="image-20230515215531531" style="zoom:67%;" />

**死锁的定义：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-3.png" alt="image-20230515215623681" style="zoom:67%;" />

**死锁的必要条件：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-4.png" alt="image-20230515215701759" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-5.png" alt="image-20230515215716324" style="zoom:67%;" />

**处理死锁的方法：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-6.png" alt="image-20230515215748151" style="zoom:67%;" />

## 预防死锁

由于互斥条件是不可共享设备必须的，所以只能尝试破坏后三个必要条件。

**破坏请求和保持条件：**

1.所有程序在开始前必须一次性申请运行时所有需要的资源。所以在整个运行期间不会再发出请求，即保持了就不会请求。

缺点是有可能一些资源只是程序开始时用到，后面就不用了，一直不释放会降低利用率。

2.第二种协议：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-7.png" alt="image-20230515220140004" style="zoom:67%;" />

**破坏不可抢占条件：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\3-5-8.png" alt="image-20230515220233255" style="zoom:67%;" />

**破坏循环等待条件：**

将系统中的资源进行线性排序，进程只能按照顺序递增请求资源。这样避免发生循环申请资源。

缺点是限制了新设备的增加以及限制了编程。

## 避免死锁

在资源动态分配的过程中，防止系统进入不安全状态，以避免发生死锁。

**安全状态**指的就是系统能够按照某种进程推进顺序为每个进程分配所需资源，直至满足每个进程对于资源的最大请求，使得每个进程都可顺利完成。这个进程推进顺序就是安全序列。无法找到这样一个序列就是不安全状态。

只要处于安全状态就不会出现死锁，不处于安全状态有可能进入死锁。

**银行家算法**避免死锁：

当进程请求资源时，需要判断将资源分配给进程之后是否会进入不安全状态。

书上的例题看一看。

## 死锁的检测和解除

通过将资源分配图进行简化判断是否存在死锁，如果资源分布图不可完全简化，则死锁发生。

死锁的解除：（1）从一个或多个进程中抢占资源，分配给死锁进程；（2）终止进程（终止所有进程或者逐步终止进程）

# 第四章 存储器管理

## 存储器层次结构

![image-20230516102903341](D:\RegularFile\CSLearning\2.操作系统\image\4-1-1.png)

CPU寄存器和主存又称为可执行存储器，是OS内存管理的范围；

辅存的管理是OS设备管理的范围。

## 程序的装入和链接

编译：源程序到目标模块

链接：目标模块与需要的库函数链接形成装入模块

装入：由装入程序将装入模块装入内存

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-1-2.png" alt="image-20230518091639099" style="zoom: 67%;" />

**程序装入方式：**

1.绝对装入：对于单道程序系统，完全可以知道程序将驻留在内存的什么地方，所以编译之后程序的地址均为绝对地址（即物理地址）

2.可重定位装入方式：即在装入时把程序中的指令和数据的逻辑地址修改为物理地址。（每个程序可以看作一个段，每个段内是程序的逻辑地址，比如都从0开始，但是由于多道程序的存在，不可能把所有的程序都放到物理地址为0的地方。）

3.动态运行时的装入方式：转入后并不立即把逻辑地址转化为物理地址，因为程序在内存中的位置有可能发生变化。所以推迟到程序执行时才进行转换。

（比如采用逻辑地址向物理地址转化，比如采用这种f方式：段地址+段内地址（逻辑地址）=物理地址，重定位寄存器保存段地址）

**程序链接方式：**

将目标模块与所需的库函数装配成一个装入模块。

1.静态链接：在程序运行之前将目标模块与库·函数链接成一个装入模块。修改多个程序文件的相对地址以及变换外部调用符号（比如函数调用）

2.装入时动态链接：边装入边链接，即在装入时发现外部调用时就让装入程序去找出相应的外部调用模块并链接。

3.运行时动态链接：对于模块的链接推迟到程序执行时进行，在运行时发现需要调用外部模块时，由OS去找该模块，并装入内存。加快装入过程以及节省内存空间。

1对应着静态链接库，都需要预先链接才能形成装入模块（可执行程序）；3对应动态链接库，即等到程序运行时发现需要模块时才去找动态链接库。

## 连续分配存储管理方式

为了将程序装入内存，必须给程序分配一段内存空间。

连续分配指的是程序所占用的空间是一段连续的内存地址空间。

### 单一连续分配

指的是早期单道程序，内存区分为系统去和用户区，系统区留给OS，内存区仅由一道应用程序占用。

一般不需要内存保护，应用程序只能破坏操作系统，重新载入即可。

### 固定分区分配

将整个用户区内存划分为大小相同的区域，为每个程序分配一个分区。

**分区方式：**固定大小和分区大小不等（大量小分区，少量大分区）

分区方式：建立一个分区表，记录分区的起始地址、大小、状态等等。

### 动态分区分配

根据进程的实际需要动态地分配内存。

涉及到分区的数据结构管理、分区分配算法、分配流程和回收流程

**数据结构：**

空闲分区表和空闲分区链

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-1.png" alt="image-20230518094503332" style="zoom:67%;" />

**分配以及回收流程：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-2.png" alt="image-20230518094624905" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-3.png" alt="image-20230518094701959" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-4.png" alt="image-20230518094730205" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-5.png" alt="image-20230518094753701" style="zoom:67%;" />

**分配算法：**

1.基于顺序搜索的动态分区分配算法：将空闲分区链接成一个链，按照顺序搜索满足要求的空闲分区。

（1）首次适应（First Fit）：每次都从头开始，搜索第一个大小能够满足程序要求的分区。

优先使用地址部分，保留高址部分的大分区。缺点是不断切割地址部分分区。使得增加无法利用的内存碎片。

（2）循环首次适应（Next Fit）：每次从上次分配结束的部分开始搜索。

使得均匀使用内存空间，但是会缺少大分区。

（3）最佳适应（Best First）：将分区从小到大排序，选择刚好满足要求但是又是最小的分区分配。

所切割下来的分区永远是难以利用的碎片。

（4）最坏适应（Worst Fit）:总是挑选最大的分区进行切割。

产生碎片的可能性小。

2.基于索引搜索的动态分区分配算法：

（1）快速适应算法（Quick Fit）：将不同大小的分区连成不同的链，并为每个链建立一个索引表中的表项。

搜索时在索引表中找到一个最小的空闲区链表指针。之后去链表上取下一个分区。不会进行分割。

缺点是归还分区比较耗时。

（2）伙伴系统：分区大小总是2的k次幂。具有相同大小的分区会形成一个链。

分区方式：假如要分一个长度为n的存储空间，计算i使得$2^{i-1}<n \le 2^{i}$，然后去找2的i次幂的分区，如果没有就将一个2的i+1次幂的分区划分成两个2的i次幂的分区。一个拿来分配，一个记录到表中。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-6.png" alt="image-20230518100451045" style="zoom:67%;" />

整除说明在开始位置，所以伙伴在下面的分区；没整除说明在下面位置，伙伴在上面。

（3）哈希算法：以分区大小为关键字设立表项。相同大小的分区还是一个链。

### 动态可重定位分区分配

**紧凑：**

将内存中作业进行移动，使得都相邻。将相隔的比较小的内存空间合并成空闲分区。

每次紧凑都需要对程序的指令和数据地址进行修改。

**动态重定位：**

利用定位寄存器+逻辑地址=物理地址，紧凑时只需修改重定位寄存器地址（段地址）即可。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-7.png" alt="image-20230518100950531" style="zoom:67%;" />

流程：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-3-8.png" alt="image-20230518101009489" style="zoom:67%;" />

## 对换

**对换技术**就是将内存中暂时不能运行的进程或者暂时不用的程序或者数据换出到外存上，以腾出空间，把已经具备运行条件的进程或者进程所需要的程序和数据换入内存。

**对换的分类：**整体对换（即以整个进程为单位，也称作中极调度和进程对换）和页面（分段）对换，在下一章虚拟存储器技术中解释。

**对换空间的管理：**

将磁盘（外存）分为文件区和对换区。

文件区：占用磁盘空间的大部分，用于存放文件，由于文件的访问频率低，所以文件区管理的主要目标是提高外存利用率，一般采用离散式分配方式。

对换区：占用磁盘空间小部分，用于存放从内存患处的进程，这些进程在外存中驻留时间是短暂的，所以需要经常访问，因此对于对换区的主要目标是提高换出和换入的速度，因此采用连续分配方式。

**对于对换空间的管理：**同样是使用空间分区表或者链表示空闲分区；空闲分区的分配与回收与对于内存的连续分配方式相似。

（因为存储器管理包括内存与外存，这里用的又是连续分配方式，所以与前面的内容基本相同）

**进程的换入与换出：**

当内核发现内存不足时，调用**对换进程**，对换进程完成换入或者换出任务之后自我阻塞。

1.换出：（1）选择被换出的进程，优先选择被阻塞或者的进程，当存在多个时，选择优先级低的。如果没有阻塞进程，就选择优先级低的就绪进程换出；（2）进程换出过程：只换出非共享的程序和数据段。申请磁盘对换区空间，启动磁盘将进程的程序和数据传送到磁盘的对换区。

2.换入：对换进程定时执行换入操作。查看PCB集合中进程的状态，找出就绪但是换出的进程，如果存在多个，就选择在外存上驻留时间最久的（且大于规定时间比如2s）进程作为换入进程。为它申请内存，如果申请失败，先换出一些进程在换入这个进程。

**一般是许多进程出现经常发生缺页（说明内存紧张）才调用对换进程，当系统的缺页率下降时暂停对换程序。**

## 分页存储管理方式

分页和分段的主要思想是：连续存储管理方式需要申请一块连续的存储空间，会出现一些碎片，需要进行紧凑。那么直接将一个进程分配撞到分散的内存空间中。

**页面和物理块：**页面就是把进程的逻辑空间分成若干个大小相同的页，物理块就是把内存空间也分成固定大小且相同的块。这样就可以把进程的页装入一个物理块。

最后一页往往是装不满的，所以存在页内碎片。

**页面大小：**太小会导致一个进程占用很多页，使得页表很大占用内存；太大使得页内碎片大。一般为1KB~8KB

**地址结构：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-1.png" alt="image-20230519092028557" style="zoom:67%;" />

**页表：**

每一个进程都有一个页表，页表将页号和物理块号一一对应，实现从页号到物理块号的地址映射。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-2.png" alt="image-20230519092203712" style="zoom:67%;" />

**地址变换机构：**

将程序中的逻辑地址转换为内存的物理地址。由于页内地址和物理地址一一对应，因为一页就是一个物理块。

所以只需要将逻辑地址中的页号转换为物理块号即可，可借助页表完成。

1.基本地址变换机构：

一个页表项使用一个寄存器完成从页号到物理块号的转换。

但是不可能把页表的所有页表项装入CPU寄存器，因此需要一个**页表寄存器PTR**，存放页表在内存中的起始地址和页表的长度（即有多少个页表项）。

在进程未执行时，页表的起始地址和页表长度存放在PCB中，当执行时调入页表寄存器。

转换过程：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-3.png" alt="image-20230519092933732" style="zoom:67%;" />

2.具有快表的地址变换机构：

页表存放在内存中，所以存取数据需要两次访问内存：第一次是根据页表号到内存中查找页表的表项，或者物理块号，第二次是根据物理块号和块内逻辑地址查找内存中的数据。

因此CPU的处理速度降低一倍，所以在增加一个高速缓冲寄存器（联想寄存器），称为快表，保存一部分页表项。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-4.png" alt="image-20230519093335455" style="zoom:67%;" />

**访问内存有效时间：**

指的是进程发出访问逻辑地址请求，经过地址变换再到内存中找到数据并取出数据花费的时间。

假设访存时间为t，那么基本地址变换机构的EAT时间为：t + t = 2t

具有快表的访存时间为：
$$
EAT=a\times \lambda +\left( 1-a \right) \left( \lambda +t \right) +t=2t+\lambda -a\times t
$$
a表示命中率，λ表示访问快表时间。

**两级和多级页表**

假如进程页面很多导致页表项也很多，需要为页表创建一个页表，然后将不同的页表存放在离散的页面中。

详细看书。

**反置页表**

每一个物理块设置一个表项，按照物理块号排序，内容是页号和所隶属的进程的标识符。

地址变换时根据进程标识号和页号检索表项，检索到那么该表项的序号就是物理块号。如果没有找到说明不在内存中。

表中只包含已经调入内存的页面，并且大小就是物理块的数量。

## 分段存储管理方式

需求：方便编程、信息共享、信息保护、动态增长、动态链接

**分段：**将作业的地址空间划分为若干个段（类似于汇编语言中的段的概念），每一段采用连续地址空间。每一段并不一定相等。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-5.png" alt="image-20230519095021779" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-6.png" alt="image-20230519095041343" style="zoom:67%;" />

**段表：**

段表中的每一项记录段的起始地址和这一段的长度。从逻辑段到物理内存的映射。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-7.png" alt="image-20230519095237528" style="zoom:67%;" />

**地址变换机构**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-8.png" alt="image-20230519095312258" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-9.png" alt="image-20230519095330529" style="zoom:67%;" />

**分页和分段主要区别：**

1.页为单位和段为单位。以页为单位一段逻辑上完整的程序可能在两个页，那么执行时就需要访问两个页，如果是段就不需要访问两次页。

2.页的大小固定且由系统决定，段的大小不固定。

3.页的地址空间是一维的，段的地址空间是二维的，程序员既要给出段的地址又要给出段内地址（编译器完成）

**信息共享**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-10.png" alt="image-20230519095841887" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-11.png" alt="image-20230519095918317" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-12.png" alt="image-20230519095944589" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-13.png" alt="image-20230519100013829" style="zoom:67%;" />

重点是表项减少，比较方便，地址转换简单，但是实际上内存并没有减少。

**可重入代码**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-14.png" alt="image-20230519100146900" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-15.png" alt="image-20230519100217282" style="zoom:67%;" />

## 段页式存储管理

基本原理：把程序分成若干个段，每个段再使用分页式管理。

**地址结构：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-16.png" alt="image-20230519100348772" style="zoom:67%;" />

段表：页表地址和页表长度

页表还是页号和物理块。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-17.png" alt="image-20230519100500212" style="zoom:67%;" />

地址变换机构：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-18.png" alt="image-20230519100604706" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-19.png" alt="image-20230519100635425" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\4-5-20.png" alt="image-20230519100651531" style="zoom:67%;" />

# 第五章 虚拟存储器

虚拟存储技术实现从逻辑上扩充内存容量。

## 虚拟存储器概述

**常规存储方式特点：**

1.一次性：即一次性把作业从从外存装入内存开始运行。**实际上作业在运行时并不需要所有的程序和数据**。

2.驻留性：作业在内存中运行时全部的程序和数据都驻留在内存中。**实际上部分程序段和数据运行之后不会再使用**。

**程序局部性原理：**在一段较短的时间内，程序的执行仅局限于某个部分，相应地，访问的存储孔吉纳页局限于某个区域。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-1.png" alt="image-20230520094115796" style="zoom:67%;" />

**虚拟存储器工作情况：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-2.png" alt="image-20230520094252556" style="zoom:67%;" />

**虚拟存储器的定义：**具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的存储器系统。虚拟内存容量由内存和外存容量之和决定。

**虚拟存储器特征：**

1.多次性：一个作业的程序和数据分多次进入内存（当它们需要被执行时）

2.对换性：一个作业的程序和数据无需常驻内存，可能在内存和外存之间换进换出。

3.虚拟性：逻辑上扩充内存容量。

**虚拟存储器实现方法：**

1.分页请求系统：在分页系统上增加了请求调页功能和页面置换功能。

硬件支持：请求分页的页表机制、缺页中断、地址变换机构

软件支持：请求调页和页面置换的软件

2.请求分段系统：在分段系统上增加请求调段和分段置换功能。

硬件支持：请求分段的段表机制、缺段中断机制、地址变换机构

软件支持：请求分段和分段置换软件。

## 请求分段存储管理方式

由于页面总是固定大小，所以换入换出实现更简单，所以请求分页系统更常见。

**请求页表：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-3.png" alt="image-20230520095123666" style="zoom:67%;" />

**缺页中断机构：**

与中断一样需要经历中断响应、中断保护、中断服务、中断返回、中断恢复等过程。

区别在于：1.在指令执行期间而非CPU指令周期的末尾产生和处理中断信号；2.一条指令在执行期间可能发生多次缺页中断。（比如一个指令被分割在两个页面中，而这条指令要访问的指令或者数据也在两个页面中）

**地址变换机构：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-4.png" alt="image-20230520095437167" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-5.png" alt="image-20230520095542697" style="zoom:67%;" />

**请求页面中的内存分配：**

1.最小物理块数的确定：最小物理块数指的是保证进程能够正常运行的最小物理块数。取决于指令的格式、长度和寻址方式。比如对于单地址指令和直接寻址方式，两个物理块就可以，一个存放指令，一个存放数据。

2.内存分配策略：（1）固定分配局部置换：固定分配指的是为每个进程分配固定的物理块数，且在整个进程运行期间不改变。局部置换指的是当进程发生缺页时，只能从分配给该进程的物理块中选择一个换出。（2）可变分配全局置换：事先为每个进程分配一组物理块，当进程运行时可根据实际情况增加或者减少。全局置换指的是进程发生缺页时，从OS保留的空闲的物理块中选择一个给进程，如果没有空闲，就以所有进程的物理块作为全局，选择一块换出之后给进程。（3）可变分配局部置换。

为什么没有固定分配、全局置换：固定分配只能拥有固定数目的物理块，全局分配是增加一个新的物理块，者二者矛盾。

3.物理块分配算法：（1）平均分配：将系统的物理块平均分配给每个进程。由于没有考虑到进程的实际大小，因此对于比较大的进程不合适。

（2）按比例分配：根据进程的大小分配，大的分配多一点，小的分配少一点。、

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-6.png" alt="image-20230520100542124" style="zoom:67%;" />

（3）考虑优先权的分配：一部分按照比例分配，另一部分对于优先级高的进程增加份额。

**页面调入策略：**

1.何时调入页面：预调页策略（预测不久之后将要访问的页面调入内存，即每个进程工作集中的所有页）和请求调页策略（发生缺页时进行调页）

2.从何处调入页面：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-7.png" alt="image-20230520100938983" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-8.png" alt="image-20230520100955624" style="zoom:67%;" />

3.页面调入过程：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-9.png" alt="image-20230520101058160" style="zoom:67%;" />

4.缺页率：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-10.png" alt="image-20230520101324246" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-1-11.png" alt="image-20230520101354444" style="zoom:67%;" />

## 页面置换算法

确定将哪一个页面换出。

**抖动：**指刚被换出的页面很快又要被访问，需要重新调入。

**最佳置换算法和先进先出算法：**

1.最佳置换：选择以后永不使用或者未来最长时间不使用的页面换出。因为不可能预知未来哪个页面最长时间不使用，因此是一种理想状态。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-1.png" alt="image-20230521081726620" style="zoom:67%;" />

2.先进先出：选择最先进入内存的页面，即淘汰驻留在内存中最久的页面。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-2.png" alt="image-20230521081832577" style="zoom:67%;" />

**最近最久未使用LRU和最少使用算法：**

1.LRU：选择最近最久未使用，最近指的是过去的时间，最久未使用指的是在之前的访问过程中最久未访问的页面。

需要设置一个访问字段记录一个页面自上次访问依赖经历的时间，比如使用（1）寄存器：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-4.png" alt="image-20230521082148383" style="zoom:67%;" />

（2）栈：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-5.png" alt="image-20230521082232065" style="zoom:67%;" />

2.最少使用LFU算法：为每个页面设置一个寄存器，表示被访问的频率，但是由于直接使用计数器是不现实的（因为在1S内每个页面访问可能成千上万次）。因此选择一个时间间隔记录对于某个页面的访问，每次访问将寄存器最高位设为1，每隔100ms右移，这样最小的寄存器值对应的就是最少使用的页面。

**clock算法：**

1.简单clock算法：为每一页设置一位访问位，将所有页面链接成循环指针，每当页面被访问时，访问位设置为1。置换算法在选择时，如果访问位为0，可以选择换出，如果访问位为1，那么置0（给予第二次机会），查找下一个页面。第二次循环就一定能找到。

2.改进型：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-6.png" alt="image-20230521082921328" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-7.png" alt="image-20230521082940133" style="zoom:67%;" />

**页面缓冲算法：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-8.png" alt="image-20230521083045631" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-9.png" alt="image-20230521083126296" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-10.png" alt="image-20230521083235778" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-11.png" alt="image-20230521083301255" style="zoom:67%;" />

**访问内存有效时间：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-12.png" alt="image-20230521083340407" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-13.png" alt="image-20230521083416049" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-3-14.png" alt="image-20230521083513827" style="zoom:67%;" />

## 抖动与工作集

多道程序数量越多，CPU利用率先上升后下降：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-1.png" alt="image-20230521083631201" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-2.png" alt="image-20230521083725922" style="zoom:67%;" />

**工作集：**

缺页率与分配的物理块数：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-3.png" alt="image-20230521083809760" style="zoom:67%;" />

因此需要将分配的物理块数限制在一个合理范围内。

工作集指的就是在某段时间间隔内，进程实际要访问的页面的集合。

**预防抖动的方法：**

1.局部置换：即只从自己的物理块中进行换入和换出。缺点是如果一个进程一直等待，那么它处于磁盘IO等待队列中，也会妨碍其他进程缺页中断处理时间。

2.将工作集融入处理机调度中：当调度程序从外村调入作业时，先检查每个进程在内存中的页面（工作集）是否已经够多，如果够多就可以增加新的进程；如果不够多应该先为不够的进程分配更多的物理块。

3.利用L=S准则：L是缺页平均时间，S是平均缺页服务时间，即用于一个页面置换的时间。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-4.png" alt="image-20230521084356071" style="zoom:67%;" />

4.<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-5.png" alt="image-20230521084415546" style="zoom:67%;" />

## 请求分段存储管理方式

**硬件支持：**

1.请求段表：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-6.png" alt="image-20230521085614785" style="zoom:67%;" />

2.缺段中断机构：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-7.png" alt="image-20230521085650269" style="zoom:67%;" />

3.地址变换机构：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-8.png" alt="image-20230521085742112" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-9.png" alt="image-20230521085759418" style="zoom:67%;" />

**分段的共享与保护：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-10.png" alt="image-20230521085903340" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-11.png" alt="image-20230521085922948" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-12.png" alt="image-20230521085956796" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-13.png" alt="image-20230521090022623" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-14.png" alt="image-20230521090101612" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-15.png" alt="image-20230521090138118" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\5-4-16.png" alt="image-20230521090156612" style="zoom:67%;" />

# 第六章 输入输出系统

IO系统管理的的主要对象是IO设备以及相应的设备控制器。IO系统的主要任务是完成用户提出的IO请求，提高IO速率，以及提高设备的利用率，并未高层进程提供接口。

## IO系统的功能、模型和接口

**IO系统的功能：**

（为了方便用户使用）

1.隐藏物理设备细节：向上层提高抽象的读写命令。（这里解释了一下IO控制器的概念，包含若干个存放命令的寄存器和存放参数的寄存器，与组原中接口概念类似）

2.与设备无关性：除了抽象的IO命令，还使用抽象的逻辑来命名设备。

（为了CPU和IO设备的利用率）

3.提高处理机和IO设备的利用率

4.对IO设备进行控制

（为了共享设备以及处理错误）

5.确保对于设备的正确共享：处理独占设备和共享设备（一段时间允许多个进程同时访问的设备）

6.错误处理

**IO软件的层次结构：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-1-1.png" alt="image-20230521211900075" style="zoom:67%;" />

**IO系统的上下接口：**

1.IO系统接口：是IO系统与上层系统（文件系统、虚拟存储器系统以及用户进程等）之间的接口，向上层提供了不少与IO有关的库函数以供调用。

2.软硬件接口：上层是中断处理和设备驱动程序，下层是设备控制器。

**IO系统的分层：**

1.中断处理程序：直接与硬件进行交互，当有硬件发来中断请求信号时（组原中可知是通过中断触发器发送中断信号），在中断硬件做了初步处理之后（比如响应中断、关中断、硬件向量表根据中断字形成向量地址等等）转向中断处理程序。

2.设备驱动程序：将上层发来的抽象的IO请求转换为对于IO设备具体的命令参数，并装入设备控制器的寄存器中。由于各类设备的寄存器等硬件接口差异很大，所以设备驱动程序由硬件厂商提供。

3.设备独立性软件：实现了设备无关性。设备命令、设备分配、数据缓冲和数据高速缓冲等。

**IO系统接口：**

1.块设备接口：指的是数据的存取和传输都是以数据块为单位的设备，比如磁盘。基本特征是传输速率高，一般采用DMA传输方式的IO。

2.流设备接口：针对字符设备，指的是数据的存取和传输都是以字符为单位的设备，比如键盘、打印机等，一般使用中断处理方式的IO。

3.网络通信接口

## IO设备与IO设备控制器

执行IO操作的机械部分是IO设备，执行控制IO的电子部件称为IO设备控制器。

IO设备的类型

**IO设备与控制器之间的接口：**

设备不与CPU直接通信，而是与控制器通信。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-1-2.png" alt="image-20230521213152922" style="zoom:67%;" />

**设备控制器：**接收CPU的命令，对于IO设备进行操作。

这里对于IO控制器的描述基本与组原中对于IO接口的描述一致，比如功能、结构组成等。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-1-3.png" alt="image-20230521213312837" style="zoom:67%;" />

**内存映像IO：**

就如同组原中的统一编址和不统一编址。

指的是与内存是否统一编址，即将IO地址看作内存的扩充，超出一定界限的就是对于IO的操作，好处是不用单独为IO设备编写指令。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-1-4.png" alt="image-20230521213544138" style="zoom:67%;" />

**IO通道：**

通道具有自己的指令集，CPU只需向通道发出启动指令，通道便可以通过通道处理程序进行IO操作，相当于协处理器。

通道与处理器不同的是：指令类型单一和没有自己的内存。

通道的类型：字节多路（多个控制器连在一个通道上，通过时间片轮转的方式共享主通道）、数组选择（一次只服务一个控制器）、数组多路

## 中断机构和中断处理程序

**中断**是由于外部设备引起，因此称为外中断；**陷入**是由于CPU内部事件引起，比如运算时发生上溢、下溢、电源等错误。

中断向量表、中断优先级

屏蔽中断和嵌套中断

**中断处理程序：**

中断响应、中断保护、寻找中断处理程序入口、中断服务、中断返回。

## 设备驱动程序

**设备驱动程序功能：**

1.接收来自与设备无关的软件发来的命令和参数

2.检查用户IO请求的合法性

3.发出IO命令

4.及时响应由IO设备控制器发来的中断请求

**设备驱动程序的特点：**

1.将抽象的IO指令转换成具体的IO操作传送给控制器，又把控制器中的设备状态和IO操作完成情况反映给使用IO的进程

2.不同类型设备由于硬件不同，设备驱动程序也不同。（就像CPU的型号不同，不同的硬件对于不同的高低电平给出的反映也不同）

3.驱动程序与IO设备所采用的IO控制方式息息相关

4.驱动程序有用汇编语言书写的部分

5.驱动程序允许可重入。

**设备处理方式：**

1.为每一类设备设置一个进程，专门执行这类设备的IO操作

2.在整个系统中设置一个IO进程

3.不设专门的设备处理进程，而是为各类设备设置相应的设备驱动程序，以供用户使用或者进程调用。

**处理过程：**详细看书吧

**对IO设备的控制方式：**（与组原中相同）

1.程序查询方式；2.IO中断方式；3.DMA方式；4.IO通道方式

## 与IO设备无关的软件

设备无关性的基本含义是：应用程序中使用的设备，不局限于某个具体的物理设备。

以物理设备名使用设备时，不仅无法利用同类型的设备，当增加设备或者设备更新时均无法利用设备。

以逻辑设备名使用设备时，一种逻辑设备可以对应多个同类型的设备，比如printer对应多台打印机，如果一号打印机忙就去寻找其它打印机。

与设备无关的软件能够实现IO重定向，指的是IO操作的设备可以更换，而不必改变应用程序。

逻辑设备向物理设备转换需要逻辑设备表。

**与设备无关的软件的功能：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-1.png" alt="image-20230523080229886" style="zoom:80%;" />

**设备分配：**

1.设备分配数据结构：

（1）设备控制表（DCT）：每个设备的具体信息

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-2.png" alt="image-20230523080342170" style="zoom:80%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-3.png" alt="image-20230523080416454" style="zoom: 67%;" />

（2）控制器控制表、通道控制表、系统设备表

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-4.png" alt="image-20230523080508195" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-5.png" alt="image-20230523080528686" style="zoom:67%;" />

2.设备分配考虑的因素：

（1）设备的属性：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-6.png" alt="image-20230523080819990" style="zoom:67%;" />

（2）设备分配算法：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-7.png" alt="image-20230523080846186" style="zoom:67%;" />

（3）设备分配中的安全性：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-8.png" alt="image-20230523080930650" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-9.png" alt="image-20230523080948399" style="zoom:67%;" />

3.独占设备的分配程序

（1）基本分配流程：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-10.png" alt="image-20230523081117332" style="zoom:67%;" />

（2）进程使用逻辑设备名请求IO。

**逻辑设备名映射到物理设备：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-11.png" alt="image-20230523081248896" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-12.png" alt="image-20230523081315523" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-13.png" alt="image-20230523081337582" style="zoom:67%;" />

## 用户层IO软件

### 系统调用和库函数

**系统调用：**

应用程序通过系统调用间接调用OS中的IO进程，对于IO设备进行操作。

当执行系统调用时，CPU状态从用户态转换到核心态，然后转到操作系统的过程，由该过程完成响应操作，然后再返回到应用程序，CPU状态也变为用户态。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-14.png" alt="image-20230523081614873" style="zoom:67%;" />

**库函数：**

在C语言与UNIX系统中，系统调用与各系统使用的库函数几乎一一对应。用户通过调用相应的库函数使用系统调用。

### 假脱机（Spooling）系统

将一台物理设备虚拟为多台逻辑IO设备，使得多个用户共享一台物理IO设备。

在联机情况下采用外围操作的技术称为假脱机技术。

**SPOOLing的组成：**

建立在通道技术和多道程序技术之上。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-15.png" alt="image-20230523082151876" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-16.png" alt="image-20230523082405894" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-5-17.png" alt="image-20230523082437558" style="zoom:67%;" />

**SPOOLing技术的特点：**

1.提高了IO速度：由原先对于低速IO设备的操作变为对于高速磁盘的操作。

2.将独占设备改为共享设备：比如在假脱机打印系统中，并没有为任何进程分配设备，而是在磁盘中为进程分配一块空闲盘块。

3.实现虚拟设备功能：宏观上是多个进程在同时使用一个独占设备（比如打印机）。

**假脱机打印系统：**

实际上每个进程都是把数据暂时输出到磁盘上，当打印机空闲时才会一一打印磁盘缓冲区的数据。

**守护进程：**

是唯一可以使用独占设备的进程，其他进程将对设备的使用要求写入一个文件中，收获进程按照目录中的文件完成对于设备的请求。

## 缓冲区管理

将一些内存作为缓冲区，对缓冲区进行管理和组织，提供获得和释放缓冲区功能。、

**单缓冲区和双缓冲区：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-18.png" alt="image-20230523083423822" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-19.png" alt="image-20230523083449302" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-20.png" alt="image-20230523083515560" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-21.png" alt="image-20230523083554853" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-22.png" alt="image-20230523083616703" style="zoom:67%;" />

**环形缓冲区：**

当生产者和消费者速度相差比较大，双缓冲还是会存在等待现象。

因此引入多缓冲区机制。

1.组成：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-23.png" alt="image-20230523083826999" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-24.png" alt="image-20230523083845758" style="zoom:67%;" />

2.使用过程：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-25.png" alt="image-20230523083931315" style="zoom:67%;" />

3.进程之间的同步问题：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-26.png" alt="image-20230523084149788" style="zoom:67%;" />

**缓冲池：**

缓冲区为专门的进程服务，是一组内存块的链表。

缓冲池是公用缓冲区，包含一组管理数据结构和一组操作函数的管理机制，用户管理多个缓冲区。

1.组成：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-27.png" alt="image-20230523084431326" style="zoom:67%;" />

2.调用过程：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-28.png" alt="image-20230523084601350" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-29.png" alt="image-20230523084629764" style="zoom:67%;" />

3.工作方式

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-30.png" alt="image-20230523084718662" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-31.png" alt="image-20230523084739606" style="zoom:67%;" />

## 磁盘存储器的性能和调度

**磁盘存储器介绍：**

数据的组织、访问时间（寻道、旋转延迟、数据传输）

**磁盘调度算法：**

1.先来先服务：根据进程请求磁盘的顺序。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\6-7-32.png" alt="image-20230523085025768" style="zoom:67%;" />

2.最短寻道优先：访问磁道与当前磁头最近

3.扫描算法：从里向外-然后从外向里

4.循环扫描（CASCAN）：从里向外-再从里向外

上述扫描算法缺点是当一个进程频繁访问某个区域时，磁头一直在某处不动。

5.NStepScan：将请求分成N个队列，每个队列内部时scan，对于队列是先来先服务

6.FSCAN：只分成两个队列

# 第七章 文件系统

文件管理：专门管理在外存上的文件，提供文件存取、共享和保护功能。

## 文件和文件系统

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-1.png" alt="image-20230524082502269" style="zoom:67%;" />

**数据项：**描述某种属性的字符集，是数据组织中最小的逻辑数据单位。比如描述一个学生可以有的数据项为：学号、姓名等；

（数据项可以分为基本数据项和组合数据项）

**记录：**一组数据项的集合。比如描述一个学生时，把学号、姓名、年纪作为一个记录。为了能够唯一标识一个记录，一般需要选定一个或者几个数据项组为**关键字**。

**文件：**有结构文件是由若干个记录组成，无结构文件则是一个字符流。

文件属性：类型、长度、物理位置、建立时间。

文件名与扩展名。

文件分类：

按照用途分类：系统文件、用户文件、库文件

按照文件中数据形式分类：源文件、目标文件、可执行文件

按照存取控制属性分类：只执行文件、只读文件、读写文件

**按照组织形式和处理方式分类：**普通文件、目录文件（由文件目录组成的文件）、特殊文件（特质系统中的IO设备，将所有的IO设备视为文件，并按照文件的方式提供给用户使用，对这些文件的操作由设备驱动程序完成。

**文件系统的层次结构：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-2.png" alt="image-20230524083904002" style="zoom:67%;" />

1.对象及属性：文件系统管理的对象：文件、目录、磁盘存储空间

2.对对象操纵和管理的软件集合：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-3.png" alt="image-20230524084214713" style="zoom:67%;" />

3.文件系统的接口：向上提供对文件和记录操作的手法

（1）命令接口：作为用户与文件系统直接的接口，通过键盘终端获取文件系统的服务。

（2）程序接口：作为程序与文件系统的的接口，程序可通过系统调用获取文件系统的服务。

**文件操作：**读读了解一下：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-4.png" alt="image-20230524084508520" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-5.png" alt="image-20230524084609588" style="zoom:67%;" />

## 文件的逻辑结构

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-6.png" alt="image-20230524084831416" style="zoom:67%;" />

**按照是否有结构划分：**

1.有结构文件：由若干记录组成。根据记录长短是否一致又分为定长记录和变长记录。

2.无结构文件：将文件内容看作是字节或者字符流。

**按照文件的组织方式分类：**

1.顺序文件：一系列记录按照某种顺序排列，其中的记录可以是定长和不定长。

2.索引文件：为可变长记录的文件建立一张索引表，每个记录对应一个表项，方便检索。

3.索引顺序文件：将记录按照组划分，为每一组的第一个记录设置一个索引表中的表项。每一组还是按照一定的顺序排列。

**顺序文件：**

可以按照串结构（记录存入的先后顺序）和顺序结构（关键字的顺序）排列记录。

优点是存取效率高，缺点是查找和修改性能比较差。

记录寻址：1.隐式寻址，设置一个读指针，每当读完一个记录，就执行指针加1操作。主要问题是要读第i个记录就必须把前面的i-1个记录读完。

2.显式寻址：采用0~n-1标识n个记录，访问时采用首地址+下标*记录长度的方式。对于不定长记录就比较麻烦。

或者也可以利用关键字，通过检索关键里查找记录。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-7.png" alt="image-20230524090133709" style="zoom:67%;" />

**索引文件：**
为记录变长的文件建立一张索引表，每个记录在索引表中设立一个表项，记录长度和指针。索引表本身是一个定长文件。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-8.png" alt="image-20230524090233779" style="zoom:67%;" />

也可以选用不同的关键字制作多个索引表。

**索引顺序文件：**

以固定长度记录作为一组，将每组的第一个记录的地址保存在索引表中。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-9.png" alt="image-20230524090356034" style="zoom:67%;" />

查找速度：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-1-10.png" alt="image-20230524091027303" style="zoom:67%;" />

**直接文件和哈希文件:**

直接文件：根据关键字直接获得指定记录的物理地址

哈希文件：利用哈希函数将关键字转换为响应记录的地址。

## 文件目录

通过文件目录组织和管理文件。文件目录是一种数据结构，标识文件以及物理位置，供检索时使用。

文件目录的功能：

1.按名存取；2.提高对于目录的检索速度；3.文件共享；4.允许文件重名

**文件控制块FCB：**

描述和控制文件的数据结构，文件管理程序可以借助FCB中的信息对文件施加各种操作。文件目录可以看作是文件控制块的有序集合。文件目录也被看作是文件，称为目录文件。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-2.png" alt="image-20230524091836749" style="zoom:67%;" />

文件控制块中的一些信息：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-1.png" alt="image-20230524091808994" style="zoom:67%;" />

**索引结点：**

文件目录通常是放在磁盘上，当需要查询某个文件时，需要将文件目录调入内存进行一一匹配，由于文件目录可能比较大，需要分多次调入内存和匹配，就意味着需要多次启动磁盘。

但是实际在查找时并不需要文件那么多的详细信息，所以有的系统将文件名和文件描述信息分开，将文件描述信息单独形成一个索引结点，在文件目录中仅保存文件名和指向这个索引节点的指针。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-3.png" alt="image-20230524092204585" style="zoom:67%;" />

**磁盘上的索引节点：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-4.png" alt="image-20230524092254543" style="zoom:67%;" />

**内存上的索引节点：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-5.png" alt="image-20230524092332833" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-6.png" alt="image-20230524092348759" style="zoom:67%;" />

**简单文件目录：**

1.单级文件目录：整个系统文件中只设置一个文件目录表，表中是每一个文件的目录项。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-7.png" alt="image-20230524092547384" style="zoom:67%;" />

实现目录管理中最基本的功能——按名存取，但是缺点是：

查找速度慢、不允许重名、不便于文件共享。

只适用于单用户。

2.两级文件目录：每一个用户设立一个单独用户文件目录（UFD），系统中存在一个主目录文件，表象是用户名和指向用户目录文件的指针。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-8.png" alt="image-20230524092835927" style="zoom:67%;" />

**树形结构目录：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-9.png" alt="image-20230524093129279" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-3-10.png" alt="image-20230524093154942" style="zoom:67%;" />

路径名与当前目录。

目录的一些基本操作。

**目录查询方式：**

先根据文件名在目录中查询，找出文件的控制块或者对应索引节点，根据FCB或者索引节点中记录的文件地址找到外存位置。

主要有线性检索以及hash方法。

## 文件共享

指的是允许多个用户（进程）共享同一份文件，这样在系统中只需保留共享文件的一份副本。

**基于有向无循环图的文件共享：**

允许一个文件有多个父目录。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-4-1.png" alt="image-20230525081638058" style="zoom:67%;" />

存在的问题是：如果这这种链接关系直接存储文件的盘块号，那么当文件增大或者移动时导致盘块发生变化，那么多个父目录都要修改。

**解决方案是利用索引结点：**即将文件的所有信息都存放在一个索引结点中，文件目录中只存放文件名和相应的指针。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-4-2.png" alt="image-20230525081914493" style="zoom:67%;" />

需要注意的是索引结点中需要有索引节点被引用次数，表示有多少个父目录。

**利用符号链接实现文件共享：**

允许一个文件或者子目录有多个父目录，只有一个是主目录，主目录保存真正的文件，而其它目录保存的是一个特殊文件，比LINK类型文件，这个文件只包含被链接文件的路径，这样系统处理LINK类型文件时就根据路径找到真正的文件。

优点是不会存在前面的指针悬挂的问题，缺点是需要多次访问磁盘。

## 文件保护

影响文件安全性的主要因素有（1）人为因素；（2）系统因素；（3）自然因素

解决方案：（1）存取控制机制；（2）容错技术；（3）后备系统

本章只介绍存取控制机制，后面两个在下一章磁盘存储器管理介绍。

**保护域：**

访问权表示一个进程能够对于某对象执行的权力，使用有序对表示（对象名，权集）

保护域是进程对于一组对象访问权的集合，进程只能在指定域内执行操作。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-1.png" alt="image-20230525082716101" style="zoom:67%;" />

进程与域静态联系（即一个进程只联系一个域，在进程生命期间可用资源是固定的）

进程与域动态联系（一个进程可以对应着多个域，将进程运行划分多个阶段，每个阶段对应一个域），需要增加域切换功能

**访问矩阵：**

行表示一个域，列代表对象，每一项都是对一个对象的一组访问权。

访问矩阵中的访问权通常由资源的拥有者或者管理者决定。当创建一个新对象时，需要新增一列，确定在一行可以有访问权。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-2.png" alt="image-20230525083113352" style="zoom:67%;" />

具有域切换权的访问矩阵：

将切换作为一种权利，有这种权力的某一行也就是一个域，可以从该行跳到另一个域。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-3.png" alt="image-20230525083255711" style="zoom:67%;" />

**访问矩阵的修改：**

1.拷贝权：拥有拷贝权的域可以赋值权力到同列对象的其它域。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-4.png" alt="image-20230525083408070" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-5.png" alt="image-20230525083632634" style="zoom:67%;" />

2.所有权：拥有所有权的域可以增加或者删除同列其它行的权力。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-6.png" alt="image-20230525083816673" style="zoom:67%;" />

3.控制权：改变矩阵同一行中的各项访问权。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-7.png" alt="image-20230525084051503" style="zoom:67%;" />

**访问矩阵的实现：**

1.按列划分为每一个对象建立一张**访问控制表**（ACL）

比如对象如果是文件，就将ACL放在文件的文件控制表或者索引结点中，标志该文件可以被哪些进程访问。

2.按行划分为每个域（对映着进程）构建一张**访问权限表**（C）

描述一个用户或者一个进程对每一个文件所能执行的一组操作。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-8.png" alt="image-20230525084410269" style="zoom:67%;" />

**实现**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-9.png" alt="image-20230525084432382" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\7-5-10.png" alt="image-20230525084506021" style="zoom:67%;" />

# 第八章 磁盘存储器的管理

磁盘存储管理的任务和要求：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-1.png" alt="image-20230525084645237" style="zoom:67%;" />

## 外存的组织方式

文件的物理结构与外存组织方式有关，不同的外存组织方式形成不同的文件物理结构。

目前的外存组织方式有：

（1）连续组织方式：文件采取连续组织方式，每个文件分配一片连续的磁盘空间，由此组成的文件物理结构是顺序式文件结构。

（2）链接组织方式：为每个文件分配不连续的磁盘空间，通过链接指针将一个文件的所有盘块链接在一起。（一个盘块就是一段连续的磁盘存储空间，对应内存的物理块的概念）由此组成的文件是链接式文件结构。

（3）索引组织方式：对文件采用索引组织方式形成的将是索引式文件结构。

**连续组织方式：**

每一个文件分配一组相邻接的盘块，即文件逻辑结构上相邻接的在物理盘块中也相邻。

在文件的目录项中的“文件物理地址”记录着该文件第一个记录所在的盘块号和文件长度（以盘块为单位）

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-2.png" alt="image-20230525085700023" style="zoom:67%;" />

缺点是：如同内存的动态分区分配，随着文件的存储空间的分配与回收，将磁盘空间分成许多小块，形成外存碎片。

以及必须事先知道文件的长度。

不能灵活插入和删除。

优点：顺序访问容易、顺序访问速度快。

**链接组织方式：**

为一个文件分配不连续的盘块，通过盘块的链接指针连接。

优点：消除外部碎片、对插入、删除和修改记录比较容易、适应文件的动态增长

1.隐式链接：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-3.png" alt="image-20230525090123322" style="zoom:67%;" />

缺点：只适合顺序访问，要访问i就必须先访问前面i-1个。

2.显式链接：

把一个文件所有盘块的指针显式存放在一个链接表中，这个表称为文件分配表（FAT）

表的序号是物理盘块号，表项是链接指针，指向下一个盘块号。文件的第一个盘块号作为文件地址填在响应的FCB的“物理地址”字段中。

**详细说明了FAT技术...**

**索引组织方式：**

将FAT调入内存需要很大的空间（FAT中是所有盘块号，并不是一个文件的FAT），但是实际上打开某个文件时只需要将文件占用的盘块号调入内存即可。

因此将文件的所有盘块号集中在一起，使用时直接把盘块号调入内存即可。

为每一个文件建立一个索引表，保存该文件的所有盘块。（相当于一个文件的FAT）

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-4.png" alt="image-20230525091046630" style="zoom:67%;" />

建立多级索引：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-5.png" alt="image-20230525091122408" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-6.png" alt="image-20230525091238161" style="zoom:67%;" />

增量式索引组织方式：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-7.png" alt="image-20230525091408587" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-9.png" alt="image-20230525091501045" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-8.png" alt="image-20230525091443533" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-1-10.png" alt="image-20230525091536524" style="zoom:67%;" />

## 文件存储空间管理

为了实现文件组织方式，需要为文件分配盘块，而分配盘块就需要知道哪些盘块是空闲的。

因此需要为盘块设置一个磁盘分配表，表示盘块的状态。

对于磁盘空间的分配方式一般都是盘块而不是字节。

**1.空闲表法和空闲链表法：**

空闲表法属于连续分配方式，与内存的动态分配方式相同，为所有空闲区建立一张空闲表。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-2-11.png" alt="image-20230525091854587" style="zoom:67%;" />

盘块的分配与回收与动态分区分配类似。

**虽然内存很少利用连续分配方式，但是在外存中这种分配方式具有很高的分配速度，可以减少磁盘的IO频率。**

空闲盘块链就是把空闲盘块链接成一条链。

空闲盘区链是把盘区作为链。

**2.位示图法：**

用二进制的一位表示一个盘块的使用情况。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-1.png" alt="image-20230525092230858" style="zoom:67%;" />

盘块的分配：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-2.png" alt="image-20230525092301374" style="zoom:67%;" />

盘块的回收：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-3.png" alt="image-20230525092326332" style="zoom:67%;" />

**3.成组链接法：**（没看太懂）

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-4.png" alt="image-20230525092422790" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-5.png" alt="image-20230525092438782" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-6.png" alt="image-20230525092455486" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-7.png" alt="image-20230525092511117" style="zoom:67%;" />

## 提高磁盘IO速度

文件系统最重要的性能就是对文件的访问速度。提高文件的访问速度可以从一下三个方面：

（1）改善文件目录结构以及目录检索方法；

（2）选取好的文件存储结构；

（3）提高磁盘的IO速度

第一点和第二点已经在第七章和本章前部分介绍。下面主要介绍提高磁盘IO速度。

**1.磁盘高速缓存：**在内存中划出一部分空间作为磁盘的缓冲区，保存一些磁盘的盘块。

（1）如何将磁盘缓存中的数据交付给请求进程：数据交付（复制数据）和指针交付（将磁盘缓存的指针给进程）

（2）置换算法：常用的还是最近最久未使用（LRU），最近未使用（NRU）、最少使用（LFU）

（3）周期性写回磁盘：由于LRU算法，一直被使用的磁盘块可能很长时间不会被写入磁盘，因此需要周期性写回磁盘。

**2.一些其他方法：**

（1）提前读；（2）延迟写；（3）优化物理块分布；（4）虚拟盘（利用内存虚拟磁盘）

**3.廉价磁盘冗余阵列（RAID）**

利用一台磁盘阵列控制器统一管理和控制一组磁盘驱动器。

并行交叉存取：将原先一个盘块的数据分成若干个子盘块数据，将每一个子盘数据分别存储到各个不同磁盘的相同位置（类似组员中内存的并行交叉存储）

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-3-8.png" alt="image-20230526083421431" style="zoom:67%;" />

由于同时可以从N块中读取数据，因此速度提高了N-1倍。

## 提高磁盘可靠性

磁盘容错技术防止系统因素引发的错误，后备系统防止自然因素。

**1.第一级容错技术SFT-I**

主要是防止因磁盘表面错误引起数据丢失。

（1）双份目录和双份文件分配表

（2）热修复重定向（划分磁盘容量的一小部分区域，用于保存磁盘有缺陷的数据）和写后读校验。

**2.第二级容错技术SFT-II**

防止由于磁盘驱动器和磁盘控制器错误引起的数据问题。

（1）磁盘镜像：同一个磁盘控制器下两个磁盘驱动器。既写主磁盘又写备份磁盘。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-4-1.png" alt="image-20230526083940675" style="zoom:67%;" />

（2）磁盘双工：两台磁盘驱动分别连在两个磁盘控制器上。每个磁盘控制器都有自己的通道。

**3.基于集群技术的容错**

集群指的就是一组互连的自主计算机。

（1）双机热备份：两台服务器，一台作为主服务器，另一台作为备份服务器，当主出现问题，启用备份。

（2）双机互为备份：最好是每台服务器都有两个硬盘，一个保存自己，一个保存对方，这样当一个服务器出问题就能让另一台负责双份工作。

（3）公用磁盘：多台计算机连接到一台公共磁盘系统中。

**4.后备系统**

把暂时不用的数据存放在后备系统中保存。

磁带机、硬盘、光盘

## 数据一致性控制

指的是保存在多个文件中的同一数据，在任何情况下必须相同。

**事务：**一系列相关的读写操作，是访问和修改各种数据项的程序单位。

只有当事务所有的操作都完成才能托付（提交）操作。如果有一个读写失败就夭折（回滚）。

事务属性ACID：原子性（Atomic）、一致性（Consistent）、隔离性（Isolated）、持久性（Durable）

**事务记录：**为了实现原子修改而创建的一种数据结构。这些数据存放在稳定存取器中，记录事务运行时数据项修改的全部信息，也成为运行记录（log）

包含字段：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-1.png" alt="image-20230526084954018" style="zoom:67%;" />

事务记录中每一项记录都描述了事务运行时的操作，比如修改、开始、托付、夭折。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-2.png" alt="image-20230526085110542" style="zoom:67%;" />

**恢复算法：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-3.png" alt="image-20230526085210367" style="zoom:67%;" />

**检查点：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-4.png" alt="image-20230526085301029" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-5.png" alt="image-20230526085333507" style="zoom:67%;" />

**新的恢复算法：**

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-6.png" alt="image-20230526085423254" style="zoom:67%;" />

**并发控制：**

各事务对于数据项的修改是互斥的，只有一个事务完成，另一个事务才能执行，称为顺序性。

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-7.png" alt="image-20230526085630924" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-8.png" alt="image-20230526085712353" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-9.png" alt="image-20230526085731491" style="zoom:67%;" />

**重复数据的一致性问题：**

1.重复文件的一致性：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-10.png" alt="image-20230526085830213" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-11.png" alt="image-20230526085907011" style="zoom:67%;" />

2.链接数一致性检查：

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-12.png" alt="image-20230526090026234" style="zoom:67%;" />

<img src="D:\RegularFile\CSLearning\2.操作系统\image\8-5-13.png" alt="image-20230526090106839" style="zoom:67%;" />







