# 实验1：查看CPU和内存，使用机器指令和汇编指令编程

## debug的使用

debug提供实模式（8086方式）程序的调试工具。使用debug程序可以查看CPU中各种寄存器的内容、内存的情况在机器码级别跟踪程序的运行。

<img src=".\lab-image\1-1-0-0.png" alt="image-20230525213051538" style="zoom:67%;" />

**使用R指令：**

```c++
r // 显示CPU寄存器的内容
r x
```

参数x是cpu寄存器名字，有ax，bx，cx，dx这四个是通用寄存器，cs，ip分别是代码段寄存器和指令指针寄存器。（CPU一共有4个段寄存器，cs、ds(数据段寄存器)、ss(栈段寄存器)、es）

使用r x的方式可以修改寄存器的内容。

**使用D指令：**

d 直接列出预设的内存地址的内容

d 段地址:偏移地址会列出从指定内存单元开始的128个内存单元的内容，每一行是16个，共8行

d 段地址:起始偏移地址 结尾偏移地址 

**使用E指令：**

改写内存中的内容。

e 段地址:起始地址 数据 数据 （换行结束）

数据可以是数值（1,2,3,...）和字符（'a', 'b'...），也可以是字符串（"adc"）

也可以使用e写机器指令。

**使用U指令：**

u 段地址:起始地址 将指定内存单元开始的内容翻译成汇编指令

机器指令的地址 机器指令 机器指令对应的汇编指令

**使用T指令：**

t ：执行从cs:ip内存开始的指令。

**使用A指令：**

a 段地址:偏移地址 从指定内存位置开始写汇编指令，enter结束一行

## 实验任务

（1）写入一段程序，逐条执行。

![image-20230616210330257](.\lab-image\1-1-0.png)

<img src=".\lab-image\1-1-1.png" alt="image-20230616195352730" style="zoom: 80%;" />

**值得注意的是，当两个16位寄存器相加溢出时，最高位丢失。**

**两个8位寄存器相加结果超过8位时也会把最高位丢失。**

（2）利用下面三条指令计算2的8次方

mov ax,1
add ax,ax
jmp 2000:0003

<img src=".\lab-image\1-2-1.png" alt="image-20230616200430854" style="zoom:80%;" />

<img src=".\lab-image\1-2-2.png" alt="image-20230616201138681" style="zoom: 80%;" />

（3）查看指定rom中的生产日期

<img src=".\lab-image\1-3-1.png" alt="image-20230616201621426" style="zoom:80%;" />

<img src=".\lab-image\1-3-2.png" alt="image-20230616202052947" style="zoom:80%;" />

无法修改。

（4）向显存单元写入数据。

<img src=".\lab-image\1-4-1.png" alt="image-20230616202312598" style="zoom:67%;" />

写入乱码数据之后屏幕上出现奇怪符号。

尝试改写其它显存内容：

<img src=".\lab-image\1-4-2.png" alt="image-20230616202442439" style="zoom:67%;" />









