# 任务

<img src=".\lab-image\7-1-1.png" alt="image-20230629094541741" style="zoom:67%;" />

<img src=".\lab-image\7-121.png" alt="image-20230629094609618" style="zoom:67%;" />

<img src=".\lab-image\7-1-3.png" alt="image-20230629094630797" style="zoom:67%;" />

最开始的想法是使用一个循环21次，每一次循环中，先把第一个数组的第i个元素写进结构体的第一个位置，然后把第二个数组的第i个元素写进结构体第二个位置....

整体逻辑为：
for i in range(0, 21):
	ds:[arr1(0)]\[i]\[si] 复制到 es:[bx]\[idata(0)]\[si]	// si从0~3表示year的四个字节
	
	ds:[arr2(84)]\[i][si] 复制到 es:[bx]\[idata(5)]\[si]	// si为0，2表示收入的两个字

​	ds:[arr3(168)]\[i][si] 复制到 es:[bx]\[idata(10)]\[si]  // si为0，可省略，表示雇员人数的一个字

​	取出收入的两个字，进行除法，结果保存到es:[bx]\[idata(13)]
​	
​	bx加上16

如果使用BP寄存器保存i值，表示第几个数据元素，那么BP寄存器需要每次增加多少？对于year和dd来说，每次需要增加4个字节，对于dw来说，每次需要增加2个字节（这是由数据类型决定的，偏移量=序数*字节数），i只能表示序数，但是[BP]必须给出偏移量。
技巧：每次循环BP加2两个字节，然后先处理year和dd的前两个字节，接着处理dw的两个字节，然后加2处理year和dd的后两个字节。总之就是两种不同类型的偏移量需要两个寄存器来保存。

技巧：同时可以看出处理year是处理四次字节，可以简化为粗处理两次字，与处理收入dd处理两次字保持一致

所以整体逻辑修改为：(最终每次循环，di会每次加4（表示year和dd两种类型每次增加到偏移量），si每次加2（表示dw类型每次增加的偏移量），bx每次加16（表示table每一个表项每次增加的偏移量）)

```c++
for i in range(0, 21):
	ds:[arr1(0)][di] 复制到 es:[bx][idata(0)] // 处理year的前两个字节
	ds:[arr2(84)][di] 复制到 es:[bx][idata(5)] // 处理收入的前两个字节
	mov ax,ds:[arr1(84)][di] // 收入前两个字节放入ax
	ds:[arr3(168)][si] 复制到 es:[bx][idata(10)] // 处理人数的两个字节

	di加2
	ds:[arr1(0)][di] 复制到 es:[bx][idata(0+2)] // 处理year的后两个字节
	ds:[arr2(84)][di] 复制到 es:[bx][idata(5+2)] // 处理收入的后两个字节
	mov dx,ds:[arr2(84)][di] // 收入后两个字节放入dx

	计算平均收入放入指定位置
    div word ptr ds:[arr3(168)][si]
	mov es:[bx][idata(13)],ax
	
	add di,2	
    add si,2
    add bx,15
	
```

收获就是：结构体偏移量用BX表示，里面的数据项用idata表示，数据项里面可以用si表示，[BX].idata[SI]，对于每一个结构体来说这是一种二维表示，但是可以把每一个结构体内部看作一维表示，即使用[BX+idata]去表示结构体内部每一个字节。

程序载入之后data数据段布局
![image-20230629105006380](.\lab-image\7-1-4.png)

年份占84字节，收入占84字节，人数占42字节（-d 0b37:0 df）

table数据段布局：从0B45:0到0B59:F一共21个16字节（-d 0b45:0 14f）

<img src=".\lab-image\7-1-5.png" alt="image-20230629105514968" style="zoom:67%;" />

程序执行完毕之后：

![image-20230629120939372](.\lab-image\7-1-7.png)

















