# 规划

每天有时间就读一读，一章是30页左右。

目前5.15，读了两章

5.25，读了4章，完成了3个实验

一共17章，还剩13章，想要6月底看完的话，5周，一周2~3章左右外加实验。



时间：2023.05~2023.07，大概三个月左右

总结就是汇编语言更接近于机器语言，主要是操作CPU的寄存器，以及需要访问指定的内存单元。

编写汇编语言需要时刻考虑使用哪一个寄存器，需要访问的数据具体在哪个内存单元。

收获：加深了对于如何操作计算机硬件的理解，虽然汇编不是完全的底层，但是已经非常接近于硬件，可以说直接与硬件进行交互。

# 第一章 基础知识

汇编课程的重点在于如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作。

**机器指令**是一列二进制数，计算机将其转换为一系列高低电平，驱使计算机的电子器件进行工作完成计算。每一种微处理器，由于其硬件设计和内部结构不同，需要使用不同的电平脉冲控制，所以每一种微处理器都有自己的机器指令集，也就是机器语言。

**汇编语言**是机器语言的便于记忆的格式，需要使用汇编编译器编译为机器语言。汇编语言由三部分组成：汇编指令（机器码的助记符）、伪指令（编译器执行，计算机不执行）、其他符号（比如+、-、*等，由编译器识别，没有对应的机器码）。

存储器、指令和数据、存储单元、CPU对于存储器的读写（数据线、地址线、控制线）、不同种类的存储芯片。

**内存地址空间：**所有的物理存储器被看作由若干个存储单元构成的逻辑存储器，每一个存储器在这个逻辑存储器上占据由一个地址段，即一段地址空间。

<img src=".\image\1-1.png" alt="image-20230515080300753" style="zoom:67%;" />

# 第二章 寄存器

寄存器是CPU中程序员可以读写的部件。

**通用寄存器：**8086CPU有14个16位寄存器，其中AX、BX、CX、DX是通用寄存器，存放一般性数据，每一个16位可以分为高位和低位8位，用AH、AL表示。

**常用几条汇编指令：**move和add

<img src=".\image\2-1.png" alt="image-20230515080705056" style="zoom:67%;" />

需要注意的是：两个操作数的位数必须一致，并且在进行8位运算时不会向第9位进位。

**8086指令寻址方法：**

物理地址=段地址*16（左移4位）+偏移地址

**段：**将若干地址连续的单元看作一个段，用段地址*16定位段的起始地址，执行完一条指令之后偏移地址自动增加，以形成下一条指令的地址。

注意：段地址一定是16的倍数，并且由于偏移地址的寄存器最多16位，因此一个段长度最大为64KB。

**段寄存器：**CS：代码段寄存器，IP：指令指针寄存器。

修改CS、IP的指令有：

<img src=".\image\2-2.png" alt="image-20230515081334452" style="zoom:67%;" />

<img src=".\image\2-3.png" alt="image-20230515081354425" style="zoom:67%;" />

<img src=".\image\2-4.png" alt="image-20230515081413965" style="zoom:67%;" />

# 第三章 寄存器（内存访问）

本章的字、寄存器都是针对8086CPU而言。

**CPU的字和内存中的字：**

CPU寄存器为16位，那么一个寄存器可以看作一个字；

内存中一个存储单元是一个字节即8位，所以一个字需要内存的两个存储单元保存。

字的低位字节存放在低地址单元，高位字节存放在高地址单元。

将起始地址为N的内存字单元称为N地址字单元，包含了两个字节。

**DS段寄存器和[address]：**在8086CPU中，内存地址（物理地址）主要是由段地址+偏移地址表示，其中段寄存器DS中表示的是段地址，使用[...]表示一个内存单元，里面的...表示偏移地址。

**不支持直接将数据送到段寄存器**，因此需要先把数据送到一个通用寄存器，再通过mov指令把通用寄存器的内容赋值到DS寄存器中。

**使用mov指令一次性可以传递16位也就是一个字。**因此可以使用mov指令在寄存器和内存中进行字的交换。

mov指令操作数：数据、寄存器、段寄存器、内存单元

数据只能到寄存器，另外三种可以互相到达一共是6种，再加一种寄存器到寄存器。一共8种。

**sub指令：**使用第一个操作数减去后一个操作数并保存在第一个操作数空间。

**PS：add和sub指令无法操作段寄存器。**

**数据段：将一组内存单元定义为专门存储数据的段。**segment。

**栈：**将一段内存当作栈使用，提供push ax指令和pop ax指令。一个**段寄存器S**S和一个**普通寄存器**SP，SS表示栈顶的段地址，SP表示偏移地址，则SS：SP表示栈顶元素。

注意栈为空时，**SP指向最底部下面一个元素**，**栈满时指向SS**。
入栈时SP先加一个内存单元，再把内容入栈；出现时先出栈，再把SP减去一个内存单元。

注意**栈的越界问题**。

push 寄存器、段寄存器、内存单元

pop 寄存器、段寄存器、内存单元

**栈段：使用一组内存空间作为栈。**栈段最大为64KB，因为SP寄存器只有16位，最多表示2^16B即64KB。

**段综述：**

<img src=".\image\3-1.png" alt="image-20230518165647902" style="zoom:67%;" />

# 第四章 第一个程序

编写汇编程序、编译汇编程序、链接程序、执行程序

编译和链接之后生成可执行文件，可执行文件可分为部分：**程序（由源程序中汇编语言编译而来的机器码）和数据（源程序中的数据）**、**相关描述信息（比如文件多大）**

使用masm和link程序进行编译和链接，生成exe文件。

**谁将可执行文件装入内存并使它运行？**

<img src=".\image\4-1.png" alt="image-20230522214532470" style="zoom:67%;" />

<img src=".\image\4-2.png" alt="image-20230522214653269" style="zoom:67%;" />

**使用debug跟踪程序执行：**

CX寄存器存放的是程序的长度。

**程序加载过程：**

<img src=".\image\4-3.png" alt="image-20230522215041305" style="zoom:80%;" />

<img src=".\image\4-4.png" alt="image-20230522215121751" style="zoom:67%;" />

**使用t命令单步跟踪**

**到了INT 21需要使用p命令**



# 第五章 [BX]和loop指令

\[bx]表示一个内存单元，其偏移地址在bx寄存器中，默认的段地址在段寄存器DS中。

\[0]表示一个内存的单元，偏移地址为0，默认段地址在段寄存器DS中。

**描述内存单元**需要内存单元地址（即上面的表示方法）和内存单元的长度（由指令隐式给出，比如mov ax,\[0]和mov al,\[0]分别表示两个字节和一个字节。

定义描述符号()，表示寄存器中或者一个内存单元的物理地址。内存单元物理地址必须是一个20位的数据。具体表示的是字节还是字由寄存器决定。

约定idata表示常量。





mov ax,\[bx]：表示将段地址DS:偏移地址BX内存中的数据转移到ax中

mov \[bx],ax：表示将ax中的数据移动到段地址DS:偏移地址BX内存单元中。

**inc bx**：指令表示bx内容加1





**loop指令格式：**loop 标号

CPU执行loop指令两步操作：(cx) = (cx)-1和判断cx中的值，如果不为零则转移到标号处，如果为零则向下执行。（标号表示一个地址，这个地址处有一条指令）

实现循环：

（1）在cx中存放循环次数；

（2）loop指令中的标号所标识的地址要在前面；

（3）循环体写在标号和loop指令中间

​	mov cx, 循环次数

s:循环执行的程序段

​	loop s





**在debug中跟踪loop执行的循环程序**，书上给出详细过程。

（**注意，在汇编源程序中，数据不能以字母开头，因此需要加一个0**）

debug g 0012将代码从当前CS:IP开始执行到(IP)=0012为止。

希望将剩下的循环全部执行，使用debug的p命令，也可使使用g命令执行到循环结束后和代码地址。



对于[idata]的处理：debug将[idata]看作是一个内存地址偏移量为idata的内存单元（段地址在ds中）；而编译器将[idata]看作是常量数据idata。
如果想要在汇编源程序中表示内存单元：（1）将内存单元偏移量先放进一个寄存器，再将寄存器内容作为偏移量；（2）在[idata]前加上段寄存器和：
即ds:[idata]的形式。当然也可以是DS:[AX]的形式，DS可以省略。



loop指令与[BX]结合应用：将偏移地址放在BX中，使用[BX]的方式访问内存单元；同时每次循环体中改变BX寄存器的值（加一），这就就能访问一段连续的内存单元。



**段前缀：**指的是汇编语言中在访问内存单元指令中显式给出内存单元段地址和所在段寄存器，比如 mov AX,DS:[BX]，其中DS可以是CS、SS、ES。



一段安全的地址空间：之前写入程序都是随便想内存中写入程序（比如(CS)=2000，(IP)=0），这样做是非常危险的。
在一般的PC机中，DOS方式下，DOS和其它合法程序一般不会使用0:200~0:2ff的256个字节空间。即地址为0020：0至002f：f这段。



段寄存器ES可以指定段地址，这样DS和ES可以分别表示源段地址和目标段地址。

# 第六章 包含多个段的程序

**在代码段中使用数据：**将数据在代码段最开始进行定义，这样数据的位置就是CS:0的位置

汇编语言中dw表示定义字型数据，即两个字节的数据。

汇编语言中使用start和end start表示程序的入口地址。



**在代码段中使用栈：**在代码段最开始的位置使用dw申请一块内存，然后使用SS和SP寄存器定义这段内存为栈



**把数据、代码、栈放进不同的栈：**

1.每一段使用不同的名字标识

2.段名就代表段地址，偏移地址则是在段中的位置（需要注意的是不能将段名直接赋给一个段寄存器）

# 第七章 更灵活的定位内存地址的方法

**and和or指令：**

<img src=".\image\7-1.png" alt="image-20230627113412724" style="zoom:67%;" />

<img src=".\image\7-2.png" alt="image-20230627113440588" style="zoom:67%;" />



**ASCII码：**定义每种字符的编码规则，比如61H就表示a



**在汇编程序中给出字符数据：**db ‘......’



**大小写转换：**

<img src=".\image\7-3.png" alt="image-20230627113756963" style="zoom: 67%;" />

观察16进制可以知道，小写字母与大写字母相差20H。但是这里有一个问题，需要判断是大写字母还是小写字母，但是以目前学到的指令无法判断。

<img src=".\image\7-4.png" alt="image-20230627114006629" style="zoom:67%;" />

因此需要重新发现规律。观察可以看出，大小字母和小写字母的二进制从右向左第5位（从0开始计数）不同，其它位置都相同。

因此要使得一个字符为小写，只需把第5位设为1，反过来就设为0。



**[bx+idata]**

表示一个内存单元，偏移地址位bx中的值加上idata，默认段地址为DS寄存器中的值。



**使用[bx+idata]的方式进行数组处理：**

之前程序两个字符串看作数组，起始地址分别为0和5，那么可以使用[0+bx]和[5+bx]循环两个字符串数组。

形式可以变为：0[bx]和5[bx]

<img src=".\image\7-5.png" alt="image-20230627164200560" style="zoom:67%;" />



**SI和DI寄存器是和BX功能相近的寄存器**，不能分成两个8为寄存器使用。



**使用[BX+SI]和[BX+DI]的形式表示内存。也可以简化为[BX]\[SI]**



**使用[BX+SI+idata]的形式表示内存，简化形式为：**

<img src=".\image\7-6.png" alt="image-20230627172315813" style="zoom:67%;" />



**不同寻址方式灵活运用：**

<img src=".\image\7-7.png" alt="image-20230627172740605" style="zoom:67%;" />

如果出现需要双重循环的情况，可以在内循环中先保存CX寄存器的值，内循环结束后将CX寄存器的值再取回来。
寄存器的数量有限，因此往往不能够作为暂存CX值的地点，所以往往在内存中划出一段空间作为暂存值的空间。但是如果使用一个固定的内存空间，那就必须记住这个内存的地址，不方便。
于是我们可以使用栈最为暂存值的空间。

<img src=".\image\7-8.png" alt="image-20230628091319657" style="zoom:67%;" />

# 第八章 数据处理的两个基本问题

数据处理的基本问题：
1.处理的数据在什么地方（内存中、寄存器中等）
2.要处理的数据有多长（一个字节还是两个字节）

<img src=".\image\8-1.png" alt="image-20230628213711614" style="zoom:67%;" />



**BX、SI、DI和BP：**

<img src=".\image\8-2.png" alt="image-20230628214309929" style="zoom:67%;" />

<img src=".\image\8-3.png" alt="image-20230628214328909" style="zoom:67%;" />

<img src=".\image\8-4.png" alt="image-20230628214344760" style="zoom:67%;" />

只能是BX与SI和DI；BP与SI和DI

<img src=".\image\8-5.png" alt="image-20230628214443040" style="zoom:67%;" />



**机器指令处理的数据在什么地方：CPU内部（寄存器和运算器）、内存、端口**



**汇编语言中表示数据位置：**
1.立即数（idata）：直接包含在机器指令中的数据，比如mov ax,1中的1就是立即数

2.寄存器：使用寄存器名表示在寄存器中的数据

3.段地址和偏移地址：表示内存单元中的数据，存放段寄存器的地址可以是默认的（默认在DS中），也可以显式给出（DS:[BX]）



**寻址方式：当数据存放在内存时，可以使用多种方式给出这个内存单元的偏移地址**

![image-20230628215140275](.\image\8-6.png)



**指令要处理的数据有多长：**

1.通过寄存器指明数据长度：比如mov ax，1表示是字操作（两个字节，字的低位字节存放在低地址单元，高位字节存放在高地址单元，指向的内存单元（一个字节）是字的低地址单元）；mov al，1表示是字节操作。

2.没有寄存器存在的情况下，使用X ptr指明内存单元长度
<img src=".\image\8-7.png" alt="image-20230628215654820" style="zoom:67%;" />

3.其他方法：
<img src=".\image\8-8.png" alt="image-20230628215756558" style="zoom:67%;" />



寻址方式的应用：

<img src=".\image\8-9.png" alt="image-20230628220406515" style="zoom:67%;" />

现在要修改其中数据：

<img src=".\image\8-10.png" alt="image-20230628220442255" style="zoom:67%;" />

<img src=".\image\8-12.png" alt="image-20230628220650093" style="zoom:67%;" />

C语言描述：

<img src=".\image\8-13.png" alt="image-20230628220723623" style="zoom:67%;" />

以C语言的风格改写汇编程序：

<img src=".\image\8-14.png" alt="image-20230628220807105" style="zoom:67%;" />

<img src=".\image\8-15.png" alt="image-20230628220830363" style="zoom:67%;" />

<img src=".\image\8-11.png" alt="image-20230628220614011" style="zoom:67%;" />



**div除法指令：**

<img src=".\image\8-16.png" alt="image-20230629084636779" style="zoom:67%;" />



**字节型数据：db，字型数据：dw，双字型数据：dd**.这些都是伪指令，只有汇编语言中才会出现。

**dup：与db、dw、dd等数据定义伪指令配合使用，用于进行数据段重复。**

<img src=".\image\8-18.png" alt="image-20230629085803018" style="zoom:67%;" />

<img src=".\image\8-19.png" alt="image-20230629085827402" style="zoom:67%;" />

<img src=".\image\8-17.png" alt="image-20230629085741901" style="zoom:67%;" />

# 第九章 转移指令的原理

<img src=".\image\9-1.png" alt="image-20230629211931724" style="zoom:67%;" />

**操作符offset：**汇编语言处理的符号，作用是取得后面的标号的偏移地址
<img src=".\image\9-2.png" alt="image-20230629212053401" style="zoom:67%;" />



**jmp指令是无条件转移指令，可以只修改IP，也可以同时修改CS和IP。**
jmp指令要给出两种信息：转移的目的地址；转移到距离（段间转移、段内短转移、段内近转移）



**根据位移进行转移到jmp指令：**

jmp short 标号（转移到标号执行指令）
实现的是段内短转移，对于IP的修改范围为-128~127
**原理：**
首先需要说明的是，其它机器指令一般都需要将idata立即数包含在机器指令中，比如：
<img src=".\image\9-3.png" alt="image-20230629213955168" style="zoom:67%;" />
但是上面这种形式的转移机器指令却并不包含转移目的地址：
<img src=".\image\9-4.png" alt="image-20230629214126989" style="zoom:67%;" />

CPU执行指令的过程：
<img src=".\image\9-5.png" alt="image-20230629214222698" style="zoom:67%;" />
分析上面的指令执行过程：
<img src=".\image\9-6.png" alt="image-20230629214302712" style="zoom:67%;" />
可以看出，EB 03机器指令直接让IP寄存器加3，即在指令EB 03中告诉IP寄存器需要增加的偏移量。
偏移量计算示例：
<img src=".\image\9-7.png" alt="image-20230629214539870" style="zoom:67%;" />
<img src=".\image\9-8.png" alt="image-20230629214655550" style="zoom:67%;" />



**转移目的地址在指令中的jmp指令：jmp far ptr 标号**
实现段间转移，也成为远转移。CS内容指明标号所在段的段地址，IP内容指明标号在段中的偏移地址。
far ptr说明使用标号的段地址和偏移地址修改CS和IP。
<img src=".\image\9-9.png" alt="image-20230701092829969" style="zoom:67%;" />
机器指令高地址保存段地址，低地址保存偏移地址。

**转移地址在寄存器中的jmp指令：jmp 16位reg**
表示使用寄存器reg的内容作为IP寄存器内容



**转移地址在内存单元中的jmp指令：**
<img src=".\image\9-10.png" alt="image-20230701095047225" style="zoom:67%;" />
<img src=".\image\9-11.png" alt="image-20230701095113154" style="zoom:67%;" />



**jcxz指令：有条件转移指令**
<img src=".\image\9-12.png" alt="image-20230701095352247" style="zoom:67%;" />



**loop指令：循环指令**
<img src=".\image\9-13.png" alt="image-20230701100055735" style="zoom:67%;" />



**根据位移进行转移的好处是：程序段无论在内存的什么位置都可以是执行，因为是根据位移进行转移。如果是根据目的地址进行转移，那么程序段必须在指定位置才能执行。**
<img src=".\image\9-14.png" alt="image-20230701100559882" style="zoom:67%;" />

**另外，根据位移进行转移到指令，转移范围收到转移位移的限制，比如上面的1、3、4范围是-128\~127，2的范围是-32768\~32767。



**dec指令和inc指令功能相反，减一操作。**

**nop指令机器码为一个字节。**

# 第十章 CALL和RET指令

call和ret指令都是转移指令，修改IP或者同时修改IP和CS寄存器。通常用于子程序的设计。



**ret和retf:**
<img src=".\image\10-1.png" alt="image-20230703092328471" style="zoom:67%;" />

- <img src=".\image\10-2.png" alt="image-20230703092404767" style="zoom:67%;" />

**call指令：（1）将当前的IP或者CS和IP同时压入栈中；（2）转移。**
call指令不能实现短转移，call指令实现转移的方式与jmp指令类似、

**根据位移进行转移的call指令：**
<img src=".\image\10-3.png" alt="image-20230703093250168" style="zoom:67%;" />
<img src=".\image\10-4.png" alt="image-20230703093447020" style="zoom:67%;" />

**转移目的地址在指令中的call指令：**
<img src=".\image\10-5.png" alt="image-20230703093644660" style="zoom:67%;" />

**转移地址在寄存器中的call指令：**
<img src=".\image\10-6.png" alt="image-20230703094022645" style="zoom:67%;" />

**转移地址在内存中的指令：**
<img src=".\image\10-7.png" alt="image-20230703094400329" style="zoom:67%;" />
<img src=".\image\10-8.png" alt="image-20230703094751228" style="zoom:67%;" />



**利用call和ret实现子程序段：**
子程序框架：
<img src=".\image\10-9.png" alt="image-20230703102705070" style="zoom:67%;" />
具有子程序的源程序框架：
<img src=".\image\10-10.png" alt="image-20230703102737715" style="zoom: 67%;" />
<img src=".\image\10-11.png" alt="image-20230703102830942" style="zoom:67%;" />



**mul乘法指令：**
<img src=".\image\10-12.png" alt="image-20230703103055071" style="zoom:67%;" />



**使用寄存器在源程序和子程序之间传递参数和返回值。**
但是寄存器的数量有限，所以可以将一批参数放入内存中，然后将**参数所在内存空间的首地址放在寄存器中**传递给子程序。
另外还可以**使用栈传递参数**，但是要注意栈中的数据顺序。

**指令ret n的含义为：**
<img src=".\image\10-14.png" alt="image-20230703154235535" style="zoom:67%;" />
即弹出栈顶元素，并把栈指针向下移动n个字节。



**在子程序和主程序中可能会使用相同的寄存器，从而产生冲突。**比如经常会使用CX寄存器作为跳转指令的寄存器。因此从一个程序跳转到另一个程序中时，为了不产生寄存器冲突，需要将源程序的寄存器内容保存。
<img src=".\image\10-13.png" alt="image-20230703153953438" style="zoom:67%;" />

即在子程序开始之前将自己需要用到的寄存器入栈，这样保留了原始寄存器内容（也就是主程序可能会用到的寄存器内容）；子程序返回之前将子程序使用的寄存器再出栈，即恢复原始寄存器内容。

# 第十一章 标志寄存器

<img src=".\image\11-1.png" alt="image-20230706203107355" style="zoom:67%;" />

<img src=".\image\11-2.png" alt="image-20230706203222724" style="zoom:67%;" />



**ZF标志：第6位，零标志位，如果指令执行结束之后结果为0，那么ZF为1；否则ZF为0.**
<img src=".\image\11-3.png" alt="image-20230706203512706" style="zoom:67%;" />



**PF标志：第2位，奇偶标志位，如果指令执行之后结果所有bit位中1的个数为偶数，则PF为1；如果为奇数则为0。**

**SF标志：第7位，符号标志位，如果指令执行之后结果为负则SF为1；否则为0.**（针对有符号数运算结果的记录）

**CF标志：第0位，进位标志位，在进行无符号数运算时，记录运算结果的最高有效位向更高位的进位值，或从更高位的借位值。**

<img src=".\image\11-4.png" alt="image-20230706205422183" style="zoom:67%;" />

<img src=".\image\11-5、.png" alt="image-20230706205458590" style="zoom:67%;" />



**OF标志：第11位，溢出标志位，一般情况下记录有符号数运算的结果是否发生了溢出，发生溢出OF为1，否则为0.**

溢出指的是运算结果超出能偶表示的范围。



CF和OF标志位分别表示无符号数和有符号数运算结果的信息。
<img src=".\image\11-6.png" alt="image-20230706211920503" style="zoom:67%;" />



**adc指令：带进位加法指令，利用CF标志位上记录的进位值。**
<img src=".\image\11-7.png" alt="image-20230709091548285" style="zoom:67%;" />
利用这条指令可以计算更大的无符号数加法：
<img src=".\image\11-8.png" alt="image-20230709091653227" style="zoom:67%;" />

**sbb指令：带借位减法指令，利用CF标志位上的借位值**
![image-20230709091840535](.\image\11-9.png)



**cmp指令：**
![image-20230709092845112](.\image\11-10.png)
**对于无符号数ax - bx：**
<img src=".\image\11-11.png" alt="image-20230709093216888" style="zoom:67%;" />
**对于有符号数：**
<img src=".\image\11-12.png" alt="image-20230709093635929" style="zoom:67%;" />
但是不能仅仅根据结果的符号位SF判断两个数的大小：因为可能发生溢出现象：
![image-20230709094146386](.\image\11-13.png)

可以根据SF标志位和OF溢出位判断逻辑上的正负：
![image-20230709094800462](.\image\11-14.png)

（可以这么理解，+127向上溢出是负数，-128向下溢出是正数，所以当出现溢出OF为1并且结果为负数SF为1时，说明逻辑上运算结果应当大于127；同理说明逻辑上运算结果是小于-128）



**检测比较结果的条件转移指令：**
<img src=".\image\11-15.png" alt="image-20230709095327890" style="zoom:67%;" />

所有条件转移指令的转移位移都是[-128,127]

大多数条件转移指令都检测标志寄存器的相关位，根据检测结果来决定是否修改IP。因为cmp指令会影响标志位，所以常常和条件转移指令一起使用。

<img src=".\image\11-17.png" alt="image-20230710080957761" style="zoom:67%;" />

<img src=".\image\11-18.png" alt="image-20230710081129822" style="zoom:67%;" />

关于有符号数的比较结果进行转移的工作原理与无符号数相同，只是检测的标志位不同。



**DF标志位和串传送指令：**

<img src=".\image\11-19.png" alt="image-20230710083536705" style="zoom:67%;" />

<img src=".\image\11-20.png" alt="image-20230710083601264" style="zoom:67%;" />



**传送字节指令**：将SI偏移处字节转移到DI字节处。

<img src=".\image\11-21.png" alt="image-20230710083710399" style="zoom:67%;" />

<img src=".\image\11-22.png" alt="image-20230710083729876" style="zoom:67%;" />

<img src=".\image\11-23.png" alt="image-20230710083758630" style="zoom:67%;" />

**传送字指令：**

<img src=".\image\11-24.png" alt="image-20230710083839819" style="zoom:67%;" />

传送指令需要与rep配合使用：

<img src=".\image\11-25.png" alt="image-20230710083918006" style="zoom:67%;" />



**pushf和popf指令：**
![image-20230710084210559](.\image\11-26.png)



**debug中对于标志寄存器的标志：**
<img src=".\image\11-27.png" alt="image-20230710084957253" style="zoom:67%;" />



# 第十二章 内中断

根据计算机组成原理的知识可以知道，在计算机指令周期的结尾，CPU会检测从内部或者内部产生的中断信息。中断信息会导致CPU不再接着向下执行指令，而是转去处理这个中断信息。

中断信息可以来自CPU内部或者外部。本章研究的是内中断，即中断信息是来自CPU内部。

**内中断信息：**
<img src=".\image\12-1.png" alt="image-20230710211852787" style="zoom:67%;" />

CPU使用中断信息码来标识中断信息的来源：
（1）除法错误：0
（2）单步执行：1
（3）执行into指令：4
（4）执行int指令：该指令格式为 int n，指令中的n为字节型立即数，作为CPU的中断类型码提供给CPU。

收到不同的中断信息之后，CPU应当去执行不同的**中断处理程序**来处理中断信息。

CPU使用8位的中断类型码到**中断向量表**中寻找相应的中断处理程序的入口地址。中断向量指的就是中断处理程序的入口地址，中断向量表中是中断处理程序入口地址的列表。
CPU将**中断类型码**当作表项号，到中断向量表中寻找中断处理程序入口地址。
中断向量表在内存中，对于8086CPU而言，中断向量表从内存地址0开始，从0000:0000到0000:03FF的1024个单元中存放着中断向量表，一共256个表项，一个中断向量（也就是中断处理程序入口地址），包含两个字节的CS和两个字节的IP寄存器内容。一个表项占两个字，高地址存放段地址，低地址存放偏移地址。



**中断处理过程：**
<img src=".\image\12-2.png" alt="image-20230710214727737" style="zoom:67%;" />
<img src=".\image\12-3.png" alt="image-20230711083850744" style="zoom:67%;" />

CPU硬件自动完成中断过程：用中断类型码找到中断向量，并使用它设置CS和IP寄存器。

<img src=".\image\12-4.png" alt="image-20230711084822029" style="zoom:67%;" />



**中断处理程序：**由于CPU可能随时会发生中断，所以随时需要执行中断处理程序，所以中断处理程序必须常驻内存。
中断处理程序编写步骤：
<img src=".\image\12-5.png" alt="image-20230711085007180" style="zoom:67%;" />
iret指令使用汇编语言描述为：
<img src=".\image\12-6.png" alt="image-20230711085053034" style="zoom:67%;" />



**除法错误中断处理程序：**显示提示信息“Divide overflow”，并返回操作系统。

下面以修改处理0号中断程序的例子说明如何自定义中断处理程序：
1.定义自己的中断处理程序；
2.将中断处理程序安装到内存中某一个固定内存，这里使用的是0000:0200到0000:02FF共256个字节处；
3.将中断向量表中对应位置的中断向量改为短地址：0000，偏移地址0200

**计算段程序大小方式：使用offset end-offset start**。注意汇编语言可以处理表达式。
<img src=".\image\12-7.png" alt="image-20230711091431007" style="zoom:67%;" />

需要注意的是，在编写中断处理程序时，需要将数据保存在自己的段内。



**单步中断：**
<img src=".\image\12-8.png" alt="image-20230711093332480" style="zoom:67%;" />

如果没有单步中断，那么当计算机通电之后，就开始从预设的地址一直执行，或者程序载入内存之后就会一直执行结束。
而debug就是利用了CPU的单步中断，通过把TF标志位设置为1，并且提供中断处理程序（即将所有寄存器内容打印在屏幕上，并等待输入），以及把中断处理程序写入中断向量表。

另外值得注意的时进行中断处理程序之前，需要把TF设置为0，避免中断处理程序中执行完一条指令就发生单步中断，这样单步中断处理程序将永远无法停止。



**中断响应的特殊情况：**存在一些情况，即使发生中断，CPU也不响应中断。比如关于设置SS寄存器。需要在设置SS寄存器之后设置SP寄存器。因为如果仅在设置完SS寄存器之后就响应中断，那么SP寄存器没有设置，指向的并不是正确的栈顶。



# 第十三章 int指令

**int指令是一种内中断指令：**
<img src=".\image\12-9.png" alt="image-20230711195447258" style="zoom:67%;" />

中断处理程序也称为中断例程。



**编写一个供用户程序调用的中断例程的步骤：**
（1）编写中断处理程序的逻辑；
（2）安装程序，将其安装在0:200处；
（3）设置中断向量表，将中断程序入口地址保存在中断消息码对应的表项中



**使用int和iret实现跳转指令：**因为int会把标志寄存器、CS寄存器、IP寄存器入栈，因此可以根据程序段提供的信息去修改栈中的IP内容，以实现IP和CS的内容修改，当中断例程使用iret返回之后，就可以正常使用CS：IP地址的命令继续执行。



**BIOS和DOS提供了一些中断例程：**
<img src=".\image\12-10.png" alt="image-20230711215258447" style="zoom:67%;" />

**BIOS和DOS中断例程的安装过程：**
<img src=".\image\12-11.png" alt="image-20230711215341049" style="zoom:67%;" />

<img src=".\image\12-12.png" alt="image-20230712082159269" style="zoom:67%;" />



# 第十四章 端口

CPU与存储器的交互：
![image-20230712151415058](.\image\12-13.png)

CPU与其它芯片的交互：
![image-20230712151510963](.\image\12-14.png)

即CPU将各种芯片中拥有的寄存器当作端口，统一编址之后形成端口地址空间。

综上，CPU可以直接读写以下部分的数据：
<img src=".\image\13-1.png" alt="image-20230712151625517" style="zoom:67%;" />



端口读写命令：
![image-20230712160224421](.\image\13-2.png)
![image-20230712160311856](.\image\13-3.png)
<img src=".\image\13-4.png" alt="image-20230712160338535" style="zoom:67%;" />

**CMOS RAM芯片：**
![image-20230712160407979](.\image\13-5.png)
![image-20230712160435271](.\image\13-6.png)



**shl和shr移位指令：**
<img src=".\image\13-7.png" alt="image-20230712160521364" style="zoom:67%;" />

<img src=".\image\13-8.png" alt="image-20230712160541301" style="zoom:67%;" />

<img src=".\image\13-9.png" alt="image-20230712160558569" style="zoom:67%;" />



**CMOS RAM芯片中存储的时间信息：**
![image-20230712160703211](.\image\13-10.png)



# 第十五章 外中断

**CPU通过端口与外部设备进行联系：**
<img src=".\image\15-1.png" alt="image-20230714083119449" style="zoom:67%;" />



当外设输入到达时，相关芯片会向CPU发出相应的中断信息。CPU在一个指令周期结尾可以检测发送过来的中断信息，引发中断过程，处理外设的输入。外中断可以分为可屏蔽中断（CPU可以不响应的中断）和不可屏蔽中断（系统中必须处理的信息）。

几乎所有的外设输入都是可屏蔽中断。

<img src=".\image\15-2.png" alt="image-20230714083552875" style="zoom:67%;" />



**PC机处理键盘输入的过程：**
1.键盘输入：按下一个按键或者松开一个按键都会产生一个扫描码。按下产生的扫描码称为通码，松开的称为断码。扫描码长度为一个字节（位），通码的第七位为0，断码的第七位为1。
断码 = 通码 + 80H

扫描码被送入60H端口中。

2.引发9号中断：
![image-20230714083921756](.\image\15-3.png)

3.指令9号中断例程：
<img src=".\image\15-4.png" alt="image-20230714084052489" style="zoom:67%;" />
<img src=".\image\15-5.png" alt="image-20230714084242327" style="zoom:67%;" />



**安装新的int9中断时：**
1.读取输入，端口号60H

2.调用新的int9中断例程（在新的int9中断例程中要调用之前的int9例程完成一些硬件操作，因此需要保存之前的int9例程地址）

3.根据输入做相应的处理



**总结CPU对于外设输入的处理：**
<img src=".\image\15-6.png" alt="image-20230714091754269" style="zoom:67%;" />

<img src=".\image\15-8.png" alt="image-20230714091814025" style="zoom:67%;" />





**指令系统总结：**

<img src=".\image\15-9.png" alt="image-20230714091905883" style="zoom:67%;" />

<img src=".\image\15-10.png" alt="image-20230714091926515" style="zoom:67%;" />

# 第十六章 直接定址表

**之前在汇编语言中书写的”标记“，用于表示距离该条语句的内存地址。**使用offset 标号计算的是当前语句指令结束之后IP寄存器距离标号所在语句的距离。

**数据标号：不使用冒号进行标记。**表示的是该段 （段地址）：数据标号所在指令的偏移量（偏移地址）
能够表示内存单元的大小。比如 a db 1，2，3（假设段名为code，并且这是第一条声明语句）；这里a 表示 code : 0开始处的1个字节。
如果想要在一个代码段中使用代码段的数据标号，需要使用assume 伪指令声明段名保存在哪个段寄存器中，并且需要显式地位段寄存器赋值为段名的段地址。
最后就是标号可以作为数据定义：
<img src=".\image\16-1.png" alt="image-20230715200122097" style="zoom:67%;" />
<img src=".\image\16-2.png" alt="16-2" style="zoom:67%;" />



直接定址表：指的是可以根据需要访问的数据直接计算出存放在数据表中的位置。即在数据和存放需要访问的元素的表的位置之间建立映射关系。

同样可以利用数据标号能够作为数据保存的特性，将子程序入口使用数据标号进行标记，然后保存在一个表中，根据输入的值计算数据标号在表中的偏移地址，取出表中的数据标号对应的数据，然后作为IP寄存器内容进行call。

# 第十七章 使用BIOS进行键盘输入和磁盘读写

BIOS的 int9中断例程和int16H中断例程：
![image-20230715201614593](.\image\17-1.png)



**字符串输入：书上的例子**



**使用int13H中断例程对于磁盘进行读写：**
读：
<img src=".\image\17-2.png" alt="image-20230715205207260" style="zoom:67%;" />
写：
<img src=".\image\17-3.png" alt="image-20230715205236542" style="zoom:67%;" />

























