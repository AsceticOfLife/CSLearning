# 实验2 用机器指令和汇编指令编程

## debug的补充使用

**d、e、a、u这些可以操作内存单元的指令：**

其中操作的内存单元形式是：段地址:偏移地址，这里的**段地址可以替换为段寄存器**，由段寄存器中的内容给出。

## mov ss, ax

当修改栈段寄存器SS的内容时，它的下一条指令（实验中一般都是修改SP寄存器，SP寄存器是普通寄存器，因此可以直接将数据写入SP）会自动被执行。

是由于中断机制导致栈内内容发生变化。

## 实验任务

（1）逐条执行下面的代码

<img src=".\lab-image\2-1-5.png" alt="image-20230616204725792" style="zoom:67%;" />

![image-20230616203628999](.\lab-image\2-1-1.png)

初始化栈段之后，原本全0的内存出现一些非0内容：

![image-20230616204222527](.\lab-image\2-1-2.png)

但是不会影响非栈段内容：

![image-20230616204317251](.\lab-image\2-1-3.png)

执行初始化栈之后的两条指令：

![image-20230616204640034](.\lab-image\2-1-4.png)

![image-20230616204855101](.\lab-image\2-1-6.png)

![image-20230616205156900](.\lab-image\2-1-7.png)

**入栈之后原本栈中的内容也移动了！**

再次push，栈中元素又移动了。

![image-20230616205256726](.\lab-image\2-1-8.png)

执行pop：

![image-20230616205559556](.\lab-image\2-1-9.png)

虽然栈剩余元素没有变化，但是栈的空内容发生了一些不稳定变化，原本的21 62已经发生变化。

执行下一条pop：

![image-20230616205731378](.\lab-image\2-1-10.png)

执行下一步：

![image-20230616205850504](.\lab-image\2-1-11.png)

![image-20230616205927889](.\lab-image\2-1-12.png)

![image-20230616210046861](.\lab-image\2-1-13.png)



（2）思考为什么栈中的元素还未赋值就已经发生变化。

分配栈段时需要发生中断，中断需要使用栈段。

