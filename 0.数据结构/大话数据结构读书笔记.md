# 第一章 绪论

<img src=".\image-data-structure\1-1.png" alt="image-20230315211050084" style="zoom:67%;" />

<img src=".\image-data-structure\1-2.png" alt="image-20230315211149424" style="zoom:67%;" />



# 第二章 算法介绍



# 第三章 线性表

## 线性表形式化定义

<img src=".\image-data-structure\3-1.png" alt="image-20230315211247045" style="zoom: 80%;" />

![image-20230315211313739](.\image-data-structure\3-2.png)



## 线性表抽象数据类型

<img src=".\image-data-structure\3-3.png" alt="image-20230315211412692" style="zoom: 67%;" />

<img src=".\image-data-structure\3-4.png" alt="image-20230315211436004" style="zoom:67%;" />

## 顺序存储结构

<img src=".\image-data-structure\3-5.png" alt="image-20230316160914625" style="zoom:80%;" />



### 获取元素

<img src=".\image-data-structure\3-6.png" alt="image-20230316161107137" style="zoom:67%;" />

<img src=".\image-data-structure\3-7.png" alt="image-20230316161125651" style="zoom:67%;" />

### 添加元素

<img src=".\image-data-structure\3-8.png" alt="image-20230316161209468" style="zoom:67%;" />

<img src=".\image-data-structure\3-9.png" alt="image-20230316161234162" style="zoom:67%;" />

### 删除操作

<img src=".\image-data-structure\3-10.png" alt="image-20230316161311858" style="zoom:67%;" />

<img src=".\image-data-structure\3-11.png" alt="image-20230316161335120" style="zoom:67%;" />

<img src=".\image-data-structure\3-12.png" alt="image-20230316161353929" style="zoom:67%;" />

### 插入和删除操作时间复杂度

$$
\frac{1}{n}\sum_{i=1}^n{\left( n-i \right)}=\frac{1}{n}\times \frac{n\left( n-1+n-n \right)}{2}=\frac{n-1}{2}
$$

### 线性存储结构优缺点

<img src=".\image-data-structure\3-13.png" alt="image-20230316161918130" style="zoom:67%;" />

## 链式存储结构-单链表

<img src=".\image-data-structure\3-14.png" alt="image-20230316164635878" style="zoom:67%;" />

<img src=".\image-data-structure\3-16.png" alt="image-20230316165026059" style="zoom:67%;" />

<img src=".\image-data-structure\3-17.png" alt="image-20230316165059908" style="zoom:67%;" />

### 有无头结点的差别

<img src=".\image-data-structure\3-15.png" alt="image-20230316164738316" style="zoom:67%;" />

**插入和删除的区别在于:**

（1）无头结点时：p->next = L;

（2）有头结点时：p->next = L->next;

很明显后者和结点操作一样。

### 单链表的读取

<img src=".\image-data-structure\3-18.png" alt="image-20230316165131116" style="zoom:67%;" />

<img src=".\image-data-structure\3-19.png" alt="image-20230316165149993" style="zoom:67%;" />

<img src=".\image-data-structure\3-20.png" alt="image-20230316165210450" style="zoom:67%;" />

时间复杂度是O(n)

### 单链表的插入

<img src=".\image-data-structure\3-21.png" alt="image-20230316165344375" style="zoom:67%;" />

<img src=".\image-data-structure\3-22.png" alt="image-20230316165359391" style="zoom:67%;" />

由于每个结点的位置信息都只保留在前继结点中，所以要先保存后面节点的信息，再断开连接。

对于拥有头结点的单链表的表头和表尾操作是相同的：

<img src=".\image-data-structure\3-23.png" alt="image-20230316165612908" style="zoom:67%;" />

<img src=".\image-data-structure\3-24.png" alt="image-20230316165632100" style="zoom:67%;" />

<img src=".\image-data-structure\3-25.png" alt="image-20230316165655222" style="zoom:67%;" />

### 单链表的删除

<img src=".\image-data-structure\3-26.png" alt="image-20230316165750742" style="zoom:67%;" />

<img src=".\image-data-structure\3-27.png" alt="image-20230316165856523" style="zoom:67%;" />

<img src=".\image-data-structure\3-28.png" alt="image-20230316165911625" style="zoom:67%;" />

<img src=".\image-data-structure\3-29.png" alt="image-20230316165934379" style="zoom:67%;" />

### 整表创建

头插法：

<img src=".\image-data-structure\3-33.png" alt="image-20230316170142815" style="zoom:67%;" />

<img src=".\image-data-structure\3-30.png" alt="image-20230316170027969" style="zoom:67%;" />

<img src=".\image-data-structure\3-31.png" alt="image-20230316170047276" style="zoom:67%;" />

<img src=".\image-data-structure\3-32.png" alt="image-20230316170105380" style="zoom:67%;" />

尾插法：

用一个指针r始终指向链表的尾结点：

r->next = p;

<img src=".\image-data-structure\3-34.png" alt="image-20230316170320741" style="zoom:67%;" />

r = p;

<img src=".\image-data-structure\3-35.png" alt="image-20230316170406870" style="zoom:67%;" />

<img src=".\image-data-structure\3-36.png" alt="image-20230316170437608" style="zoom:67%;" />

<img src=".\image-data-structure\3-37.png" alt="image-20230316170503039" style="zoom:67%;" />

### 整表删除

<img src=".\image-data-structure\3-38.png" alt="image-20230316170539086" style="zoom:67%;" />

<img src=".\image-data-structure\3-39.png" alt="image-20230316170557232" style="zoom:67%;" />

每次都用q保存p指向的结点的下一个结点，因为释放p指向的结点之后就只有通过q来找到下一个结点。

### 单链表与顺序存储结构对比

<img src=".\image-data-structure\3-40.png" alt="image-20230316170813397" style="zoom:67%;" />

## 静态链表

对于没有指针的语言如何描述单链表？使用数组描述链表叫静态链表。

### 静态链表描述与创建

数组中每个元素是一个结构体：

<img src=".\image-data-structure\3-5-1.png" alt="image-20230328215850933" style="zoom:80%;" />

<img src=".\image-data-structure\3-41.png" alt="image-20230328215918501" style="zoom:80%;" />

**对第一个元素和最后一个元素特殊处理：**

<img src=".\image-data-structure\3-42.png" alt="image-20230328215956643" style="zoom:80%;" />

<img src=".\image-data-structure\3-43.png" alt="image-20230328220029416" style="zoom:80%;" />

<img src=".\image-data-structure\3-47.png" alt="image-20230328220517200" style="zoom:80%;" />

### 静态链表插入

<img src=".\image-data-structure\3-46.png" alt="image-20230328220456902" style="zoom:80%;" />

**获取新结点：**

<img src=".\image-data-structure\3-44.png" alt="image-20230328220156787" style="zoom:80%;" />

<img src=".\image-data-structure\3-45.png" alt="image-20230328220359177" style="zoom:80%;" />

### 静态链表删除

<img src=".\image-data-structure\3-48.png" alt="image-20230328220600297" style="zoom:80%;" />

**释放（归还结点）：**

<img src=".\image-data-structure\3-53.png" alt="image-20230328220819827" style="zoom:80%;" />

<img src=".\image-data-structure\3-51.png" alt="image-20230328220743922" style="zoom:80%;" />

<img src=".\image-data-structure\3-52.png" alt="image-20230328220758549" style="zoom:80%;" />

### 其它操作

与单链表类似。比如获取长度：

<img src=".\image-data-structure\3-54.png" alt="image-20230328220913491" style="zoom:80%;" />

### 静态链表优缺点

<img src=".\image-data-structure\3-55.png" alt="image-20230328220940564" style="zoom:80%;" />

## 循环链表

单链表的结构想要遍历就必须从头结点开始，而循环链表可以从任意一个结点开始遍历。

<img src=".\image-data-structure\3-56.png" alt="image-20230329094256893" style="zoom:80%;" />

通常需要一个头结点，为了保持空链表与非空链表处理一致。

**带有头结点的空循环链表：**

<img src=".\image-data-structure\3-57.png" alt="image-20230329094406631" style="zoom:80%;" />

**带有头结点的非空循环链表：**

<img src=".\image-data-structure\3-58.png" alt="image-20230329094447245" style="zoom:80%;" />

### 循环链表访问尾结点和头结点时间复杂度为1

不再使用头指针，而是使用指向终端结点的尾指针：

<img src=".\image-data-structure\3-59.png" alt="image-20230329094614022" style="zoom:80%;" />

**将两个尾指针的循环链表合并非常容易：（如果是单链表的话需要先找到其中一个的尾指针）**

<img src=".\image-data-structure\3-60.png" alt="image-20230329094747994" style="zoom:80%;" />





## 双向链表

<img src=".\image-data-structure\3-61.png" alt="image-20230329094910634" style="zoom:80%;" />

**线性表的双向链表存储结构：**

<img src=".\image-data-structure\3-62.png" alt="image-20230329094945464" style="zoom:80%;" />

### 双向循环链表

<img src=".\image-data-structure\3-63.png" alt="image-20230329095050792" style="zoom:80%;" />

<img src=".\image-data-structure\3-64.png" alt="image-20230329095119546" style="zoom:80%;" />

### 循环链表插入和删除

**插入：先搞定插入结点的前驱和后继，再进行上链操作。**

<img src=".\image-data-structure\3-65.png" alt="image-20230329095451976" style="zoom:80%;" />

<img src=".\image-data-structure\3-66.png" alt="image-20230329095511355" style="zoom:80%;" />

如果先进行第4步，那就找不到下一个节点，比较麻烦。思想就是能先保存链上的信息就先多保存一份链上的信息。

**删除：先让前一个结点找到后一个结点，再让后一个结点指向前一个结点**

<img src=".\image-data-structure\3-67.png" alt="image-20230329095838032" style="zoom:80%;" />

<img src=".\image-data-structure\3-68.png" alt="image-20230329100247332" style="zoom:80%;" />

<img src=".\image-data-structure\3-69.png" alt="image-20230329100345823" style="zoom:80%;" />

如果先进行2的话，好像也没问题。



## 总结

<img src=".\image-data-structure\3-70.png" alt="image-20230329100458783" style="zoom:80%;" />

# 第四章 栈与队列

## 栈的定义

<img src=".\image-data-structure\4-1-1.png" alt="image-20230404114242172" style="zoom:80%;" />

<img src=".\image-data-structure\4-1-2.png" alt="image-20230404114319217" style="zoom:80%;" />

**注意可能的出栈次序的问题，如果按照一定顺序进栈，那么$a_n$出栈时，代表它进过栈，那么$a_1...a_{n-1}$也都已经进过栈了**。可以肯定它们曾经按照顺序进栈，因此出出栈顺序必定是后者先后出。

## 栈的抽象数据类型

<img src=".\image-data-structure\4-2-1.png" alt="image-20230404114953869" style="zoom:80%;" />

## 栈的顺序存储结构

top指向栈顶元素（另一种实现是top指向栈顶元素的下一个元素）

<img src=".\image-data-structure\4-3-1.png" alt="image-20230404115114044" style="zoom:80%;" />

由于数组下标从0~MaxSize，top指向第length个元素，对应的数组下标是length-1，所以栈空时top为-1；栈满时top为Max-1。

<img src=".\image-data-structure\4-3-2.png" alt="image-20230404115140450" style="zoom:80%;" />

### 顺序存储结构的进栈

![image-20230404115352916](.\image-data-structure\4-3-3.png)

<img src=".\image-data-structure\4-3-4.png" alt="image-20230404115450198" style="zoom:80%;" />

### 出栈操作

<img src=".\image-data-structure\4-3-5.png" alt="image-20230404115521550" style="zoom:80%;" />

## 两栈共享空间

同类型的数据。

用处：两个栈。一个栈增加导致另一个栈减少。

<img src=".\image-data-structure\4-4-1.png" alt="image-20230404115657397" style="zoom:80%;" />

<img src=".\image-data-structure\4-4-2.png" alt="image-20230404115727402" style="zoom:80%;" />

<img src=".\image-data-structure\4-4-3.png" alt="image-20230404115745746" style="zoom:80%;" />

入栈操作：

<img src=".\image-data-structure\4-4-4.png" alt="image-20230404115812898" style="zoom:80%;" />

<img src=".\image-data-structure\4-4-5.png" alt="image-20230404115832019" style="zoom:80%;" />

出栈操作：

<img src=".\image-data-structure\4-4-6.png" alt="image-20230404115851499" style="zoom:80%;" />

## 栈的链式存储结构

不需要头结点，以top指向第一个元素。栈空就是top==NULL。

<img src=".\image-data-structure\4-5-1.png" alt="image-20230404115956140" style="zoom:80%;" />

<img src=".\image-data-structure\4-5-2.png" alt="image-20230404120030812" style="zoom:80%;" />

### 链式存储进栈操作

<img src=".\image-data-structure\4-5-3.png" alt="image-20230404120102317" style="zoom:80%;" />

<img src=".\image-data-structure\4-5-4.png" alt="image-20230404120125897" style="zoom:80%;" />

<img src=".\image-data-structure\4-5-5.png" alt="image-20230404120141166" style="zoom:80%;" />

### 出栈操作

<img src=".\image-data-structure\4-5-6.png" alt="image-20230404120209280" style="zoom:80%;" />

<img src=".\image-data-structure\4-5-7.png" alt="image-20230404120228380" style="zoom:80%;" />

## 顺序栈和链栈对比

<img src=".\image-data-structure\4-6-1.png" alt="image-20230404120335606" style="zoom:80%;" />

## 栈的应用

### 递归调用

<img src=".\image-data-structure\4-7-1.png" alt="image-20230404171009804" style="zoom:80%;" />

### 四则运算求表达式

对于表达式：

<img src=".\image-data-structure\4-7-2.png" alt="image-20230404171159476" style="zoom:80%;" />

#### **对于后缀表达式求值（栈用来进出运算的数字）：**

其后缀表达式为：

<img src=".\image-data-structure\4-7-3.png" alt="image-20230404171224540" style="zoom:80%;" />

从左到右处理字符，如果是数字就入栈，如果遇到运算符就从栈中取出两个操作数（四则运算都是两个操作数）计算结果。

#### 根据中缀表达式求后缀表达形式

输入：

<img src=".\image-data-structure\4-7-2.png" alt="image-20230404171159476" style="zoom:80%;" />

从左向右处理字符，如果是数字就输出到结果序列中；

如果是运算符，则判断其与栈顶（栈用来存储运算符）运算符的优先级：如果是左括号就入栈；如果是右括号，就将栈顶元素一直出栈，直到左括号也出栈（括号不入最终结果表达式）；如果运算符优先级低于或者等于栈顶运算符，则出栈栈顶元素并接着比较，直到优先级高于栈顶运算符进栈（==因为后缀表达式越靠前说明运算符应该越先运算，因此栈中优先级高的运算符应该先写入最终表达式；同样如果优先级相同由于先入栈的运算符在中缀表达式中位置比准备入栈的运算符靠左，所以也要出栈==）

## 队列的抽象数据类型

**队列定义：**

同样是线性表，但是插入只能在队尾进行，删除只能在队首进行。

**抽象数据类型：**

<img src=".\image-data-structure\4-8-1.png" alt="image-20230404172648614" style="zoom:80%;" />

## 顺序存储结构的循环队列

### 队列顺序存储的不足

入队操作：

<img src=".\image-data-structure\4-9-1.png" alt="image-20230404200337520" style="zoom:80%;" />

出队操作：

<img src=".\image-data-structure\4-9-2.png" alt="image-20230404200403829" style="zoom:80%;" />

**每次出队都需要把队列元素向前移动，因此并不以0下标位置为队列首元素，而设置front表示首元素下标，rear指向队尾元素：**

队列空和队列满：

<img src=".\image-data-structure\4-9-3.png" alt="image-20230404200727519" style="zoom:80%;" />

存在问题是：随着出队元素增加，整个队列前面的空间未被利用；以及当队列元素增加时rear可能会溢出。

<img src=".\image-data-structure\4-9-4.png" alt="image-20230404200826545" style="zoom:80%;" />

### 循环队列

**使得队列头尾相连，即当rear超出数组最后一个元素时，从数组首元素开始。**

<img src=".\image-data-structure\4-9-5.png" alt="image-20230404202648788" style="zoom:80%;" />

**为了方便区别表示队列空（front==rear）队列满，令rear指向超尾元素，并且空出一个元素，当rear与front相差1时表示队列满。**

队列满：（rear+1）mod MaxSize == front。因为：1.rear与front相差1时表示队列满，所以rear + 1 == front；2.由于rear可能比front大或小，并且由于数组下标范围为0~MaxSize-1（即front和rear的取值范围），刚好是mod MaxSize的集合，所以有如上表达式。

**长度计算公式：**

1.当rear大于front时，长度为rear-front；2.当front大于rear时，长度为MaxSize-front（后面的元素） +  rear-0（开始的元素）

所以计算公式为：rear-front+MaxSize mod MaxSize。

存储结构代码：

<img src=".\image-data-structure\4-9-6.png" alt="image-20230404203522885" style="zoom:80%;" />

初始化为空列表代码：

<img src=".\image-data-structure\4-9-7.png" alt="image-20230404203551058" style="zoom:80%;" />

求长度代码：

<img src=".\image-data-structure\4-9-8.png" alt="image-20230404203616274" style="zoom:80%;" />

<img src=".\image-data-structure\4-9-9.png" alt="image-20230404203632785" style="zoom: 80%;" />

入队操作：

<img src=".\image-data-structure\4-9-10.png" alt="image-20230404203703379" style="zoom:80%;" />

出队操作：

<img src=".\image-data-structure\4-9-11.png" alt="image-20230404203722202" style="zoom:80%;" />

## 链式存储结构队列

其实就是单链表的插入操作只能从尾部，删除操作只能从头部。仍需要头结点。

增加一个指向尾结点的指针。

<img src=".\image-data-structure\4-9-12.png" alt="image-20230404204003049" style="zoom:80%;" />

空队列：

<img src=".\image-data-structure\4-9-13.png" alt="image-20230404204021956" style="zoom: 80%;" />

<img src=".\image-data-structure\4-10-1.png" alt="image-20230404204038885" style="zoom:80%;" />

入队操作：

<img src=".\image-data-structure\4-10-2.png" alt="image-20230404204104888" style="zoom:80%;" />

<img src=".\image-data-structure\4-10-3.png" alt="image-20230404204119555" style="zoom:80%;" />

出队操作：

<img src=".\image-data-structure\4-10-4.png" alt="image-20230404204142319" style="zoom:80%;" />

<img src=".\image-data-structure\4-10-5.png" alt="image-20230404204158583" style="zoom:80%;" />

<img src=".\image-data-structure\4-10-6.png" alt="image-20230404204214794" style="zoom:80%;" />

## 顺序队列和链队列对比

<img src=".\image-data-structure\4-11-1.png" alt="image-20230404204315467" style="zoom:80%;" />

## 总结

<img src=".\image-data-structure\4-12-1.png" alt="image-20230404204350020" style="zoom:80%;" />

<img src=".\image-data-structure\4-12-2.png" alt="image-20230404204431651" style="zoom:80%;" />

<img src=".\image-data-structure\4-12-3.png" alt="image-20230404204448187" style="zoom:80%;" />

# 第五章 串

## 串的定义

<img src=".\image-data-structure\5-1-1.png" alt="image-20230405152043685" style="zoom:80%;" />

<img src=".\image-data-structure\5-1-2.png" alt="image-20230405152127394" style="zoom:80%;" />

## 串的比较

**相等：**

<img src=".\image-data-structure\5-1-3.png" alt="image-20230405152225038" style="zoom:80%;" />

**不相等：**

<img src=".\image-data-structure\5-1-4.png" alt="image-20230405152248292" style="zoom:80%;" />

## 串的抽象数据类型

与线性表不同，线性表操作的主要是单个元素，串操作的是字串。

<img src=".\image-data-structure\5-3-1.png" alt="image-20230405152400036" style="zoom:80%;" />

<img src=".\image-data-structure\5-3-2.png" alt="image-20230405152421713" style="zoom:80%;" />

### 找字串下标实现方法

借助抽象数据类型的方法：StrLength、SubString、StrCompare

<img src=".\image-data-structure\5-3-3.png" alt="image-20230405152518068" style="zoom:80%;" />

<img src="C:\Users\10985\AppData\Roaming\Typora\typora-user-images\image-20230405152541744.png" alt="image-20230405152541744" style="zoom:80%;" />

## 串的存储结构

### 顺序存储结构

<img src=".\image-data-structure\5-4-1.png" alt="image-20230405152647238" style="zoom:80%;" />

采用定长数组的方式实现存在一些问题，比如两串的连接、新串的插入都有可能会超出最大长度。

**因此实际中使用顺序存储结构一般采用动态申请的策略。**

### 链式存储结构

<img src=".\image-data-structure\5-4-2.png" alt="image-20230405152914950" style="zoom:80%;" />

链式存储结构用的比较少。

因为每一个结点如果只存储一个字符的豪话太浪费空间。

因此往往一个结点存储定长的字符，末尾没存满的结点使用不会用到的字符填充。

## 朴素的模式匹配算法

字串的定位操作通常称为模式匹配。

主串S，字串T

<img src=".\image-data-structure\5-5-1.png" alt="image-20230405162429025" style="zoom:80%;" />

<img src=".\image-data-structure\5-5-2.png" alt="image-20230405162455997" style="zoom:80%;" />

<img src=".\image-data-structure\5-5-3.png" alt="image-20230405162518863" style="zoom:80%;" />

<img src=".\image-data-structure\5-5-4.png" alt="image-20230405162904520" style="zoom:80%;" />

<img src=".\image-data-structure\5-5-5.png" alt="image-20230405162933554" style="zoom:80%;" />

### 算法复杂度分析

**最好的情况：**

第一次就匹配成功，时间复杂度为1

**平均情况：**

每次只是首字母不同，S与T首字符相同时，剩下的字符也完全匹配，则时间复杂度为O(n+m),n是主串S的长度，m是字串T的长度。

根据等概率原则：
$$
\frac{1}{n}\sum_{i=1}^n{i+m}=\frac{1}{n}\times n\times \frac{\left( 1+m \right) +\left( n+m \right)}{2}=\frac{2m+n+1}{2}
$$
因此时间复杂度为O(m+n)

**最坏情况：**

<img src=".\image-data-structure\5-5-6.png" alt="image-20230405164250303" style="zoom:80%;" />

即每次首字符都匹配，但是T循环最后一位不匹配，直到S的最后一位才匹配成功。

<img src=".\image-data-structure\5-5-7.png" alt="image-20230405164308909" style="zoom:80%;" />

即执行(n-m)*m + m次才成功，时间复杂度为O((n-m+1）\*m)



## KMP模式匹配算法

### KMP算法原理

**传统方法分析1：**

<img src=".\image-data-structure\5-6-1.png" alt="image-20230405172608780" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-2.png" alt="image-20230405172726288" style="zoom:80%;" />

当T串中首字符不与后面的字符相等，即：$t_1 \ne t_2,...t_j$

而已经在本次循环中比较过S串和T串中的部分，即：$s_1=t_1,s_2=t_2,...s_j=t_j$

所以可得到：$t_1 \ne s_1,s_2,...s_j $

因此T串的首字符下一次比较不需要与$s_1...s_j$进行，直接与最后一个不相等的元素位置开始即可。

<img src=".\image-data-structure\5-6-3.png" alt="image-20230405173933442" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-4.png" alt="image-20230405174007233" style="zoom:80%;" />

这就保证了i值不会回溯。

**传统方法分析2：**

如果T字符串有重复字符怎么比较：

<img src=".\image-data-structure\5-6-5.png" alt="image-20230405191828251" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-6.png" alt="image-20230405191852504" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-7.png" alt="image-20230405191919429" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-8.png" alt="image-20230405191937609" style="zoom:80%;" />

因此，如果在已经比较过的（指的是与S串中逐一比较过，即T串的左边部分）T串中有前缀和后缀相同的字串，那么由于后缀已经和S串比较过，所以只需要从S串中与前缀相同（也同样是与后缀相同）的后一位开始比较即可，**即 j 是前缀的下一位，i 是上次循环比较的最后一次S串与T串中字符不相同的位置**。

**总结：**

i 的位置不会发生回溯，这与传统的比较方式不同（传统的方式i总是不断从1增加到k（k是与T串比较时不同的字符的序数）；

j 的位置（即下一次循环时的位置）只与自身的重复规律有关，**其实就是与当前字符之前的字符串（T串已经比较过的字符串）中前缀和后缀的关系有关**。

<img src=".\image-data-structure\5-6-9.png" alt="image-20230405193022100" style="zoom:80%;" />

**注意前缀和后缀不能都等于已经比较过的字符串的长度，即k<j。**

### KMP模式匹配算法实现

**求next数组：**

<img src=".\image-data-structure\5-6-10.png" alt="image-20230405193703449" style="zoom:80%;" />

**KMP模式匹配：**

<img src=".\image-data-structure\5-6-11.png" alt="image-20230405193738341" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-12.png" alt="image-20230405193802706" style="zoom:80%;" />

### 算法复杂度分析

**求next数组的时间复杂度：**只涉及到对于串T的循环，所以时间复杂度是O(m)

**KMP模式匹配：**由于 i 不会再回溯，所以时间复杂度是O(n)

因此总的时间复杂度是O(m+n)，比传统的方法O((n-m+1)*m)要好一些。

需要注意的是，只有当子串中有很多重复部分，KMP才能体现出优势。

### KMP算法改进

<img src=".\image-data-structure\5-6-13.png" alt="image-20230405194238236" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-14.png" alt="image-20230405194259412" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-15.png" alt="image-20230405194413720" style="zoom:80%;" />

这个过程描述的是当出现不匹配时，要根据next数组选择 j 的位置，如果当前字符不与S串匹配，**那么next指向的字符如果与该字符相同**，就都不会与这个·S串中的字符相等，因此可以把next指向的字符对应next值给这个字符。

<img src=".\image-data-structure\5-6-16.png" alt="image-20230405200244866" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-17.png" alt="image-20230405200301885" style="zoom:80%;" />

<img src=".\image-data-structure\5-6-18.png" alt="image-20230405200646122" style="zoom:80%;" />

## 总结

<img src=".\image-data-structure\5-7-1.png" alt="image-20230405200725680" style="zoom:80%;" />

# 第六章 树

## 树的定义

<img src=".\image-data-structure\6-1-1.png" alt="image-20230406170335532" style="zoom:80%;" />

树的定义是递归定义，因此只有递归到结点数为1（0也可以）才能确定是不是树。

1.n>0时根节点是唯一的；2.m>0时子树的个数没有限制，但是一定是互不相交的。

**结点分类：**

<img src=".\image-data-structure\6-1-2.png" alt="image-20230406170642637" style="zoom:80%;" />

**结点关系：**

<img src=".\image-data-structure\6-1-3.png" alt="image-20230406170709533" style="zoom:80%;" />

<img src=".\image-data-structure\6-1-4.png" alt="image-20230406170723994" style="zoom:80%;" />

**树的相关概念：**

<img src=".\image-data-structure\6-1-5.png" alt="image-20230406170803790" style="zoom:80%;" />

<img src=".\image-data-structure\6-1-6.png" alt="image-20230406170829040" style="zoom:80%;" />

**森林是m个互不相交的树的集合。**

**对比线性表和树：**

<img src=".\image-data-structure\6-1-7.png" alt="image-20230406170911064" style="zoom:80%;" />

## 树的抽象数据类型

<img src=".\image-data-structure\6-2-1.png" alt="image-20230406170948966" style="zoom:80%;" />

## 树的存储结构

只用顺序结构虽然可表示出所有的树的结点，但是无法反映诸如双亲、孩子结点的关系。

因此需要使用**顺序结构和链式结构的结合**表示树。

### 双亲表示法

<img src=".\image-data-structure\6-3-1.png" alt="image-20230406171217308" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-2.png" alt="image-20230406171240181" style="zoom: 50%;" />

<img src=".\image-data-structure\6-3-3.png" alt="image-20230406171257048" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-4.png" alt="image-20230406171322779" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-5.png" alt="image-20230406171338033" style="zoom:80%;" />

**这样寻找某个结点的双亲结点非常方便，时间复杂度为O(1)，但是寻找孩子结点就比较麻烦，需要遍历寻找结点判断其parent是否为双亲结点序号。**

**寻找孩子结点的改进：**

<img src=".\image-data-structure\6-3-6.png" alt="image-20230406171613843" style="zoom:80%;" />

**寻找兄弟结点的改进：**

增加一个右兄弟指针域。

<img src=".\image-data-structure\6-3-7.png" alt="image-20230406171703354" style="zoom:80%;" />

### 孩子表示法

<img src=".\image-data-structure\6-3-8.png" alt="image-20230406171818085" style="zoom:80%;" />

**方案一：**

<img src=".\image-data-structure\6-3-9.png" alt="image-20230406171843149" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-10.png" alt="image-20230406171912528" style="zoom:80%;" />

指针域空间会造成浪费。

**方案二：**

<img src=".\image-data-structure\6-3-11.png" alt="image-20230406171937973" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-12.png" alt="image-20230406171952927" style="zoom:80%;" />

每个结构体是不相同的，遍历会增加时间消耗。

**孩子表示法：**

<img src=".\image-data-structure\6-3-13.png" alt="image-20230406172047569" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-14.png" alt="image-20230406172157280" style="zoom:80%;" />

结构数组（存储所有结点的结构体）+ 子结点链表（也就是子树头结点）

<img src=".\image-data-structure\6-3-15.png" alt="image-20230406172323150" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-16.png" alt="image-20230406172339503" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-17.png" alt="image-20230406172403131" style="zoom:80%;" />

寻找孩子或者某个结点的兄弟都非常简单，但是寻找双亲结点不方便。

**孩子表示法改进：**

结构数组的结构体增加一个双亲结点下标：

<img src=".\image-data-structure\6-3-18.png" alt="image-20230406172532576" style="zoom:80%;" />

### 孩子兄弟表示法

<img src=".\image-data-structure\6-3-19.png" alt="image-20230406172644866" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-20.png" alt="image-20230406172727963" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-21.png" alt="image-20230406172747960" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-22.png" alt="image-20230406172831002" style="zoom:80%;" />

<img src=".\image-data-structure\6-3-23.png" alt="image-20230406172846836" style="zoom:80%;" />

## 二叉树的定义

<img src=".\image-data-structure\6-4-2.png" alt="image-20230407203541580" style="zoom:80%;" />

<img src=".\image-data-structure\6-4-1.png" alt="image-20230407203511862" style="zoom:80%;" />

**二叉树特点：**

1.最多右两颗子树；

2.左子树和右子树是有顺序的；

3.左子树和右子树不同，即使只有一颗树也要区分左和右。

**二叉树五种基本形态：**

1.空树；2.只有一个根节点；3.根节点只有左子树；4.根节点只有右子树；5.根节点既有左子树又有右子树。

<img src=".\image-data-structure\6-4-4.png" alt="image-20230407204012952" style="zoom:67%;" />

### 特殊的二叉树

**1.斜树：**

<img src=".\image-data-structure\6-4-3.png" alt="image-20230407203956746" style="zoom: 67%;" />

**2.满二叉树：**

<img src=".\image-data-structure\6-4-5.png" alt="image-20230407204043194" style="zoom:67%;" />

<img src=".\image-data-structure\6-4-6.png" alt="image-20230407204114469" style="zoom:67%;" />

**3.完全二叉树：**

<img src=".\image-data-structure\6-4-7.png" alt="image-20230407204204539" style="zoom:67%;" />

**按层次编号，意味着如果有下一层，那么上一层一定是满的。**

<img src=".\image-data-structure\6-4-8.png" alt="image-20230407204259287" style="zoom:80%;" />

## 二叉树的性质

**性质1：二叉树第i层结点数最多为$2^{i-1}$个结点。**

**性质2：深度为k的二叉树最多有$2^k-1$个结点。**根据性质1利用数学归纳法；或者使用等比数列求和。

**性质3：任何二叉树，终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。**证明：设度为1的结点数为$n_1$，那么总的结点数为$n = n_0+n_1+n_2$，根据**所有出度之和为n-1=$2n_2+n_1$**，可得结论。

**性质4：具有n个结点的完全而二叉树的深度为$\lfloor \log _2n \rfloor +1$。**证明：深度为k的满二叉树的结点数$n=2^k-1$，倒推可得满二叉树的度数为$k=\lfloor \log _2(n+1) \rfloor $。由于完全二叉树的性质，它的结点数一定小于等于同样深度的满二叉树$2^k-1$，但是一定大于小一个深度的满二叉树$2^{k-1}-1$。又由于n是整数，所以$n<2^k-1$，且$2^{k-1}\le n$。因此可得$k-1 \le log_2n$，由于k是整数，得证。

**性质5：**

<img src=".\image-data-structure\6-4-9.png" alt="image-20230407211514862" style="zoom:80%;" />

证明：只要能够满二叉树的双亲结点索引与孩子结点索引的关系$index_{p} = \lfloor index_{c} / 2\rfloor$即可。

假设第k层是孩子结点所在位置，那么双亲结点在的第k-1层一定是满的。那就以第k层第一个为孩子结点。

孩子结点的索引：$2^{k-1}-1$（前面k-1层结点数之和）+ 1（该层的序数）、$2^{k-1}-1$（前面k-1层结点数之和）+ 2（该层的序数）

双亲结点的索引： $2^{k-2}-1$（前面k-1层结点数之和）+ 1

可证索引关系，进而证明性质5。

## 二叉树的存储结构

### 顺序存储结构

<img src=".\image-data-structure\6-5-1.png" alt="image-20230408194609505" style="zoom:67%;" />

<img src=".\image-data-structure\6-5-2.png" alt="image-20230408194633313" style="zoom:67%;" />

<img src=".\image-data-structure\6-5-3.png" alt="image-20230408194650009" style="zoom: 67%;" />

<img src=".\image-data-structure\6-5-4.png" alt="image-20230408194718821" style="zoom:67%;" />

### 链式存储结构-二叉链表

<img src=".\image-data-structure\6-5-5.png" alt="image-20230408194753732" style="zoom: 67%;" />

<img src=".\image-data-structure\6-5-7.png" alt="image-20230408194837091" style="zoom:67%;" />

<img src=".\image-data-structure\6-5-6.png" alt="image-20230408194814741" style="zoom:67%;" />

## 遍历二叉树

### 二叉树遍历定义

<img src=".\image-data-structure\6-6-1.png" alt="image-20230408200940333" style="zoom:80%;" />

访问：可以替换为其他动作

次序：因为在计算机执行次序中，只会线性执行，因此必须有一个线性顺序。

### 遍历方法

**1.前序遍历：**

<img src=".\image-data-structure\6-6-2.png" alt="image-20230408201145677" style="zoom: 80%;" />

<img src=".\image-data-structure\6-6-3.png" alt="image-20230408201201635" style="zoom:80%;" />

<img src=".\image-data-structure\6-6-4.png" alt="image-20230408201224675" style="zoom:80%;" />

**2.中序遍历：**

<img src=".\image-data-structure\6-6-5.png" alt="image-20230408201318043" style="zoom:67%;" />

<img src=".\image-data-structure\6-6-6.png" alt="image-20230408201340945" style="zoom:80%;" />

**3.后序遍历：**

<img src=".\image-data-structure\6-6-7.png" alt="image-20230408201411370" style="zoom:80%;" />

<img src=".\image-data-structure\6-6-8.png" alt="image-20230408201427380" style="zoom:80%;" />

<img src=".\image-data-structure\6-6-9.png" alt="image-20230408201535982" style="zoom:80%;" />

**4.层序遍历：**

<img src=".\image-data-structure\6-6-10.png" alt="image-20230408201613476" style="zoom:67%;" />

### 推导遍历结果

**主要思路是：根节点一定是一个结点，区分根节点之后，就能判断左子树和右子树。**

<img src=".\image-data-structure\6-6-11.png" alt="image-20230408201726119" style="zoom:80%;" />

## 二叉树的建立

<img src=".\image-data-structure\6-8-1.png" alt="image-20230408202316686" style="zoom:80%;" />

<img src=".\image-data-structure\6-8-2.png" alt="image-20230408202348862" style="zoom:67%;" />

<img src=".\image-data-structure\6-8-3.png" alt="image-20230408202406931" style="zoom:67%;" />

## 线索二叉树

### 线索二叉树原理

**二叉树链表的指针域浪费：**

<img src=".\image-data-structure\6-9-1.png" alt="image-20230408203853373" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-2.png" alt="image-20230408203917780" style="zoom: 67%;" />

<img src=".\image-data-structure\6-9-3.png" alt="image-20230408204133673" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-4.png" alt="image-20230408204201985" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-5.png" alt="image-20230408204219513" style="zoom:80%;" />

<img src=".\image-data-structure\6-9-6.png" alt="image-20230408204236289" style="zoom:80%;" />

### 线索二叉树存储结构定义

<img src=".\image-data-structure\6-9-7.png" alt="image-20230408204314514" style="zoom:80%;" />

<img src=".\image-data-structure\6-9-8.png" alt="image-20230408204340281" style="zoom:80%;" />

### 线索二叉树结构实现

<img src=".\image-data-structure\6-9-9.png" alt="image-20230408204435371" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-10.png" alt="image-20230408204500295" style="zoom: 67%;" />

<img src=".\image-data-structure\6-9-11.png" alt="image-20230408204542870" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-12.png" alt="image-20230408205325474" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-13.png" alt="image-20230408205410183" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-14.png" alt="image-20230408205426824" style="zoom:80%;" />

遍历代码：

<img src=".\image-data-structure\6-9-15.png" alt="image-20230408205457422" style="zoom:80%;" />

<img src=".\image-data-structure\6-9-16.png" alt="image-20230408205528421" style="zoom: 80%;" />

<img src=".\image-data-structure\6-9-17.png" alt="image-20230408205656042" style="zoom:67%;" />

<img src=".\image-data-structure\6-9-18.png" alt="image-20230408205838582" style="zoom:80%;" />



## 树、森林与二叉树的相互转换

### 树转换为二叉树

主要思想就是把树中一个结点的左孩子、右兄弟作为两个孩子结点。

<img src=".\image-data-structure\6-10-1.png" alt="image-20230409081827958" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-2.png" alt="image-20230409081851859" style="zoom:80%;" />

### 将森林转换成二叉树

主要思想：每个树转换成二叉树，然后依次把后面的二叉树的跟结点作为前一个二叉树的右孩子。

<img src=".\image-data-structure\6-10-.png" alt="image-20230409082002381" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-3.png" alt="image-20230409082021904" style="zoom:67%;" />

### 二叉树转换为树

<img src=".\image-data-structure\6-10-4.png" alt="image-20230409082106177" style="zoom: 67%;" />

<img src=".\image-data-structure\6-10-5.png" alt="image-20230409082127271" style="zoom: 67%;" />

<img src=".\image-data-structure\6-10-6.png" alt="image-20230409082301198" style="zoom:67%;" />

### 二叉树转换为森林

<img src=".\image-data-structure\6-10-7.png" alt="image-20230409082338379" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-8.png" alt="image-20230409082417825" style="zoom:67%;" />

### 树和森林的遍历

<img src=".\image-data-structure\6-10-9.png" alt="image-20230409082552363" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-6.png" alt="image-20230409082301198" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-10.png" alt="image-20230409082812970" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-11.png" alt="image-20230409082845573" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-8.png" alt="image-20230409082417825" style="zoom:67%;" />



<img src=".\image-data-structure\6-10-12.png" alt="image-20230409083016437" style="zoom:67%;" />

## 赫夫曼树及其应用

### 赫夫曼树定义和原理

<img src=".\image-data-structure\6-10-13.png" alt="image-20230409085320025" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-14.png" alt="image-20230409085356801" style="zoom:67%;" />

**主要思想：权重越小的结点路径长度越长，就会使得整个树的权重之和减小。**

<img src=".\image-data-structure\6-10-15.png" alt="image-20230409085417473" style="zoom:67%;" />

### 赫夫曼编码

<img src=".\image-data-structure\6-10-16.png" alt="image-20230409085607983" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-17.png" alt="image-20230409085623589" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-18.png" alt="image-20230409085643125" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-19.png" alt="image-20230409085700078" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-20.png" alt="image-20230409085721930" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-22.png" alt="image-20230409085823959" style="zoom:67%;" />

<img src=".\image-data-structure\6-10-21.png" alt="image-20230409085803547" style="zoom:67%;" />

# 第七行章 图

## 基本概念和抽象数据类型

<img src=".\image-data-structure\7-1-1.png" alt="image-20230421104229817" style="zoom:67%;" />

<img src=".\image-data-structure\7-1-2.png" alt="image-20230421104313920" style="zoom:67%;" />

## 存储结构

### 邻接矩阵

<img src=".\image-data-structure\7-2-1.png" alt="image-20230421104422602" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-2.png" alt="image-20230421104446705" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-3.png" alt="image-20230421104516400" style="zoom:67%;" />



<img src=".\image-data-structure\7-2-4.png" alt="image-20230421104544029" style="zoom:67%;" />

存储结构代码：

<img src=".\image-data-structure\7-2-5.png" alt="image-20230421104631772" style="zoom:67%;" />

创建过程代码：

<img src=".\image-data-structure\7-2-6.png" alt="image-20230421104658567" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-7.png" alt="image-20230421104716380" style="zoom:67%;" />

**缺点在于如果边数比较少会浪费空间。**

### 邻接表

<img src=".\image-data-structure\7-2-8.png" alt="image-20230421104831665" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-10.png" alt="image-20230421104952438" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-11.png" alt="image-20230421105024839" style="zoom:67%;" />



<img src=".\image-data-structure\7-2-9.png" alt="image-20230421104918763" style="zoom:67%;" />

存储结点定义：

<img src=".\image-data-structure\7-2-12.png" alt="image-20230421105111677" style="zoom:67%;" />

头插法创建：

<img src=".\image-data-structure\7-2-13.png" alt="image-20230421105155605" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-14.png" alt="image-20230421105213907" style="zoom:67%;" />



### 十字链表

邻接表的缺点在于：表示有向图的时候只能表示出边或者使用逆邻接表表示入边。

重新定义结点结构：

<img src=".\image-data-structure\7-2-15.png" alt="image-20230421105416249" style="zoom:67%;" />

重新定义边结构：

<img src=".\image-data-structure\7-2-16.png" alt="image-20230421105459495" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-17.png" alt="image-20230421105518224" style="zoom:67%;" />

### 邻接多重表

邻接表表示无向图时对于一个边进行了多次保存（即所有结点的边链表中都保存了依附于自己的边）

因此优化只保存一个边副本：

<img src=".\image-data-structure\7-2-18.png" alt="image-20230421105741670" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-19.png" alt="image-20230421105805687" style="zoom:67%;" />

### 边集数组

主要关注边的信息：

<img src=".\image-data-structure\7-2-20.png" alt="image-20230421105852301" style="zoom:67%;" />

<img src=".\image-data-structure\7-2-21.png" alt="image-20230421105919994" style="zoom:67%;" />

## 图的遍历





















# 第八章 查找

## 查找定义

**查找表就是由同一类型的元素（或记录，每一条记录都由多个数据项组成）构成的集合。**

**关键字（Key）是数据元素中某个数据项的值。若此关键字可以唯一地标识一个记录，则称为主关键字，可以识别多个记录的关键字称为次关键字。**

![image-20230411102628456](.\image-data-structure\8-1-1.png)

<img src=".\image-data-structure\8-1-2.png" alt="image-20230411102711852" style="zoom:80%;" />

<img src=".\image-data-structure\8-1-3.png" alt="image-20230411102729990" style="zoom:80%;" />

<img src=".\image-data-structure\8-1-4.png" alt="image-20230411102806222" style="zoom:67%;" />

## 顺序表查找

**将数据集合排列成线性表，然后对于线性表进行查找操作。**

<img src=".\image-data-structure\8-1-5.png" alt="image-20230411102931266" style="zoom:80%;" />

顺序表查找算法：

<img src=".\image-data-structure\8-1-6.png" alt="image-20230411102953108" style="zoom:80%;" />

顺序表查找算法优化：

由于每次查找都要比较下标是否越界，因此可以设置哨兵，即将目标值放在线性表的一个位置，迭代时与该位置的值进行比较。

<img src=".\image-data-structure\8-1-7.png" alt="image-20230411103201085" style="zoom:67%;" />

**时间复杂度O(n)**

## 有序表查找

### 折半查找

<img src=".\image-data-structure\8-3-1.png" alt="image-20230411103315187" style="zoom:67%;" />

<img src=".\image-data-structure\8-3-2.png" alt="image-20230411103336302" style="zoom:67%;" />

<img src=".\image-data-structure\8-3-3.png" alt="image-20230411103403306" style="zoom:80%;" />

时间复杂度：

由于是按顺序排列的，类似于一个完全二叉树结构，因此假设结点数是n，那么查找次数就是深度k = $\lfloor log_2 n\rfloor + 1$。

因此时间复杂度为O($log n$)。

### 插值查找

<img src=".\image-data-structure\8-3-4.png" alt="image-20230411103844592" style="zoom:80%;" />

<img src=".\image-data-structure\8-3-5.png" alt="image-20230411103916523" style="zoom: 80%;" />

### 斐波那契查找

<img src=".\image-data-structure\8-3-6.png" alt="image-20230411104000827" style="zoom:80%;" />

<img src=".\image-data-structure\8-3-7.png" alt="image-20230411104018002" style="zoom:80%;" />

<img src=".\image-data-structure\8-3-8.png" alt="image-20230411104112192" style="zoom:80%;" />

<img src=".\image-data-structure\8-3-9.png" alt="image-20230411104134680" style="zoom: 67%;" />

## 线性索引查找

一些数据记录由于数据量过于大，不适合排序存储，因而只能按照先后顺序存储。

对于这种数据记录查找的方法就是**建立索引**。索引就是把一个关键字和它对应的记录相关联的过程。

索引按照结构可以分为线性索引、树形索引、多级索引等。

这里只介绍线性索引，即把索引项集合组织为线性结构，也成为索引表。

### 稠密索引

<img src=".\image-data-structure\8-4-1.png" alt="image-20230411151853701" style="zoom:80%;" />

<img src=".\image-data-structure\8-4-2.png" alt="image-20230411151917509" style="zoom: 67%;" />

稠密索引表的索引项是按照关键码有序的排列。

索引表和数据集具有用样的长度。

### 分块索引

<img src=".\image-data-structure\8-4-3.png" alt="image-20230411152105873" style="zoom: 67%;" />

<img src=".\image-data-structure\8-4-4.png" alt="image-20230411152129730" style="zoom:50%;" />

<img src=".\image-data-structure\8-4-5.png" alt="image-20230411152148116" style="zoom:67%;" />

**时间复杂度：**

<img src=".\image-data-structure\8-4-6.png" alt="image-20230411152218111" style="zoom:67%;" />

<img src=".\image-data-structure\8-4-7.png" alt="image-20230411152240064" style="zoom:67%;" />

### 倒排索引

<img src=".\image-data-structure\8-4-9.png" alt="image-20230411152338783" style="zoom:67%;" />

<img src=".\image-data-structure\8-4-8.png" alt="image-20230411152317426" style="zoom:67%;" />

<img src=".\image-data-structure\8-4-10.png" alt="image-20230411152414298" style="zoom:67%;" />

## 二叉排序树（查找树、搜索树）

一种动态查找表，插入和删除不麻烦，并且查询效率也不低。

<img src=".\image-data-structure\8-5-1.png" alt="image-20230411161747859" style="zoom:67%;" />

<img src=".\image-data-structure\8-5-2.png" alt="image-20230411161822567" style="zoom:67%;" />

链表结点定义：

<img src=".\image-data-structure\8-5-3.png" alt="image-20230411161839558" style="zoom:67%;" />

查找算法：

<img src=".\image-data-structure\8-5-4.png" alt="image-20230411161925989" style="zoom:67%;" />

<img src=".\image-data-structure\8-5-5.png" alt="image-20230411161942421" style="zoom:67%;" />

### 二叉排序树插入操作

<img src=".\image-data-structure\8-5-6.png" alt="image-20230411162026661" style="zoom:67%;" />

<img src=".\image-data-structure\8-5-7.png" alt="image-20230411162047209" style="zoom:67%;" />

### 构建二叉树

<img src=".\image-data-structure\8-5-8.png" alt="image-20230411162125289" style="zoom:67%;" />

### 二叉树删除操作

<img src=".\image-data-structure\8-5-9.png" alt="image-20230411162155455" style="zoom:80%;" />

叶子结点：直接删除即可；

仅有左子树或者右子树的结点：将左子树或者右子树的根节点作为原结点即可。

左右子树都有的结点：找到需要删除的结点p，用它的直接前驱（中序遍历：p的左子树的最右子结点）或者直接后继（p的右子树的最左子结点）代替p的位置，再删除直接前驱或者后继即可。

<img src=".\image-data-structure\8-5-10.png" alt="image-20230411162633828" style="zoom:67%;" />

delete函数：

<img src=".\image-data-structure\8-5-11.png" alt="image-20230411163010359" style="zoom:67%;" />

<img src=".\image-data-structure\8-5-12.png" alt="image-20230411163924022" style="zoom:67%;" />

### 二叉排序树总结

插入和删除性能比较好（与线性表相比）

查找速度取决于二叉排序的层数，但是二叉排序树的形状是不确定的。比如：

<img src=".\image-data-structure\8-5-13.png" alt="image-20230411164120634" style="zoom:67%;" />

<img src=".\image-data-structure\8-5-14.png" alt="image-20230411164136146" style="zoom:50%;" />

## 平衡二叉树（AVL树）

<img src=".\image-data-structure\8-5-15.png" alt="image-20230411164212921" style="zoom:67%;" />

<img src=".\image-data-structure\8-6-1.png" alt="image-20230411164236923" style="zoom:80%;" />

<img src=".\image-data-structure\8-6-2.png" alt="image-20230411164258313" style="zoom:67%;" />

### 平衡二叉树实现原理

根据例子

<img src=".\image-data-structure\8-6-3.png" alt="image-20230411164338493" style="zoom:67%;" />

构建平衡二叉树的过程。

总结：

- 当最小不平衡子树根节点的BF大于1时，右旋；
- 当最小不平衡子树根节点的BF小于-1时，左旋。

同时需要注意，当插入结点之后，最小不平衡子树根节点的BF与它的子树的BF符号相反时，需要对子树进行旋转使得符号相同之后再对根节点进行一次反向旋转之后才能平衡。

### 平衡二叉树实现算法

树的结点结构：

<img src=".\image-data-structure\8-6-4.png" alt="image-20230411164718523" style="zoom:80%;" />

右旋操作：

<img src=".\image-data-structure\8-6-5.png" alt="image-20230411165107253" style="zoom:67%;" />

<img src=".\image-data-structure\8-6-6.png" alt="image-20230411165131157" style="zoom:67%;" />

左旋操作：

<img src=".\image-data-structure\8-6-7.png" alt="image-20230411165207226" style="zoom:80%;" />

左平衡旋转处理：

<img src=".\image-data-structure\8-6-8.png" alt="image-20230411171557005" style="zoom:67%;" />

<img src=".\image-data-structure\8-6-9.png" alt="image-20230411172130710" style="zoom:67%;" />

主函数：

<img src=".\image-data-structure\8-6-10.png" alt="image-20230411172233112" style="zoom:67%;" />

<img src=".\image-data-structure\8-6-11.png" alt="image-20230411172401766" style="zoom:67%;" />

​	<img src=".\image-data-structure\8-6-12.png" alt="image-20230411172728478" style="zoom:80%;" />

<img src=".\image-data-structure\8-6-13.png" alt="image-20230411172849367" style="zoom:67%;" />

<img src=".\image-data-structure\8-6-14.png" alt="image-20230411173049378" style="zoom:80%;" />

### 生成平衡二叉树

<img src=".\image-data-structure\8-6-15.png" alt="image-20230411173211386" style="zoom:80%;" />

## 多路查找树



## 散列表（哈希表）查找

<img src=".\image-data-structure\8-8-1.png" alt="image-20230411201827027" style="zoom:80%;" />

<img src=".\image-data-structure\8-8-2.png" alt="image-20230411201850699" style="zoom:67%;" />

**散列实现过程：**

1.存储时使用hash函数计算f(key)得到存储位置；

2.查找是同样使用hash函数计算f(key)得到存储位置。

散列技术最适合求解的问题就是查找与给定值相等的记录

缺点：

1.一种关键字对应很多记录；

2.不适合范围查找，比如查找18~22岁的同学。

hash函数设计重点是：一个简单、均匀、存储利用率高的hash函数。

<img src=".\image-data-structure\8-8-3.png" alt="image-20230411202218669" style="zoom:67%;" />

## 散列函数的构造方法

### 直接定址法

![image-20230411202303474](.\image-data-structure\8-8-4.png)

取关键字的某个线性函数值作为地址。

<img src=".\image-data-structure\8-8-5.png" alt="image-20230411202349262" style="zoom:80%;" />

### 数字分析法

<img src=".\image-data-structure\8-8-6.png" alt="image-20230411202435664" style="zoom:80%;" />

### 平方取中法

<img src=".\image-data-structure\8-8-7.png" alt="image-20230411202509737" style="zoom:80%;" />

### 折叠法

<img src=".\image-data-structure\8-8-8.png" alt="image-20230411202552668" style="zoom:80%;" />

### 除留余数法

<img src=".\image-data-structure\8-8-9.png" alt="image-20230411202704166" style="zoom:80%;" />

<img src=".\image-data-structure\8-8-10.png" alt="image-20230411202745544" style="zoom:80%;" />

### 随机数法

<img src=".\image-data-structure\8-8-11.png" alt="image-20230411202823494" style="zoom:80%;" />

### 总结

<img src=".\image-data-structure\8-8-12.png" alt="image-20230411202841990" style="zoom:80%;" />

## 处理冲突的方法

### 开放定址法

<img src=".\image-data-structure\8-8-13.png" alt="image-20230411202943114" style="zoom:80%;" />

<img src=".\image-data-structure\8-8-14.png" alt="image-20230411203039079" style="zoom:80%;" />

<img src=".\image-data-structure\8-8-15.png" alt="image-20230411203120207" style="zoom:80%;" />

**二次探测法：**

<img src=".\image-data-structure\8-8-16.png" alt="image-20230411203211659" style="zoom:80%;" />

**随机探测法：**

<img src=".\image-data-structure\8-8-17.png" alt="image-20230411203244870" style="zoom:80%;" />

### 再散列函数法

<img src=".\image-data-structure\8-8-18.png" alt="image-20230411203342161" style="zoom:80%;" />

### 链地址法

<img src=".\image-data-structure\8-8-19.png" alt="image-20230411203426449" style="zoom:80%;" />

<img src=".\image-data-structure\8-8-20.png" alt="image-20230411203449141" style="zoom:50%;" />

### 公共溢出法

<img src=".\image-data-structure\8-8-21.png" alt="image-20230411203537334" style="zoom:67%;" />

<img src=".\image-data-structure\8-8-22.png" alt="image-20230411203551966" style="zoom:50%;" />

<img src=".\image-data-structure\8-8-23.png" alt="image-20230411203606617" style="zoom:67%;" />

## 散列表查找实现

**结构定义：**

<img src=".\image-data-structure\8-8-24.png" alt="image-20230411203657967" style="zoom:67%;" />

<img src=".\image-data-structure\8-8-25.png" alt="image-20230411203725646" style="zoom:67%;" />

**初始化：**

<img src=".\image-data-structure\8-8-26.png" alt="image-20230411203748894" style="zoom:80%;" />

**定义hash函数：**

<img src=".\image-data-structure\8-8-27.png" alt="image-20230411203825984" style="zoom:80%;" />

**向hash表中插入键值：**

<img src=".\image-data-structure\8-8-28.png" alt="image-20230411203905121" style="zoom:67%;" />

<img src=".\image-data-structure\8-8-29.png" alt="image-20230411203924819" style="zoom: 67%;" />

**查找算法：**

<img src=".\image-data-structure\8-8-30.png" alt="image-20230411204007619" style="zoom:80%;" />

### 性能分析

如果没有冲突那么查找时间复杂度就是O(1)

影响冲突的因素：

1.散列函数是否均匀；

2.处理冲突的方法；

3.散列表装填因子

<img src=".\image-data-structure\8-8-31.png" alt="image-20230411204201122" style="zoom:67%;" />

## 总结





# 第九章 排序

## 排序基本概念和分类

<img src=".\image-data-structure\9-1-1.png" alt="image-20230412152617172" style="zoom:80%;" />

排序的稳定性：

<img src=".\image-data-structure\9-1-2.png" alt="image-20230412152651432" style="zoom: 80%;" />

**内排序与外排序：**

<img src=".\image-data-structure\9-1-3.png" alt="image-20230412152802906" style="zoom:80%;" />

性能：

<img src=".\image-data-structure\9-1-4.png" alt="image-20230412152914854" style="zoom:80%;" />

<img src=".\image-data-structure\9-1-5.png" alt="image-20230412152935234" style="zoom:67%;" />

<img src=".\image-data-structure\9-1-6.png" alt="image-20230412152950416" style="zoom:80%;" />

分类：

<img src=".\image-data-structure\9-1-7.png" alt="image-20230412153017908" style="zoom:67%;" />

排序结构：

<img src=".\image-data-structure\9-1-8.png" alt="image-20230412153054589" style="zoom:80%;" />

比较算法：

<img src=".\image-data-structure\9-1-9.png" alt="image-20230412153117070" style="zoom:67%;" />



## 冒泡排序

### 最简单排序实现

第i次遍历选出一个最小的元素放在第i个位置。每次遍历只影响一个元素的位置。

<img src=".\image-data-structure\9-2-1.png" alt="image-20230412153212958" style="zoom:50%;" />

<img src=".\image-data-structure\9-2-2.png" alt="image-20230412153244218" style="zoom:67%;" />

### 冒牌排序算法

第i次循环时，把从最后一个元素到第i个元素的两两元素进行比较，最小的上升的同时，也把相对较小的上升一定距离。

<img src=".\image-data-structure\9-2-3.png" alt="image-20230412153421124" style="zoom: 50%;" />

<img src=".\image-data-structure\9-2-4.png" alt="image-20230412153617595" style="zoom:67%;" />

<img src=".\image-data-structure\9-2-5.png" alt="image-20230412153634893" style="zoom:67%;" />

### 冒泡排序优化

<img src=".\image-data-structure\9-2-6.png" alt="image-20230412153723658" style="zoom:67%;" />

<img src=".\image-data-structure\9-2-7.png" alt="image-20230412153741846" style="zoom:50%;" />

<img src=".\image-data-structure\9-2-8.png" alt="image-20230412153808347" style="zoom:67%;" />

<img src=".\image-data-structure\9-2-9.png" alt="image-20230412153829783" style="zoom:67%;" />

### 复杂度分析

<img src=".\image-data-structure\9-2-10.png" alt="image-20230412153928066" style="zoom:80%;" />

## 简单选择排序

<img src=".\image-data-structure\9-3-1.png" alt="image-20230412154845522" style="zoom:67%;" />

<img src=".\image-data-structure\9-3-2.png" alt="image-20230412154908612" style="zoom:67%;" />

<img src=".\image-data-structure\9-3-3.png" alt="image-20230412154925759" style="zoom:67%;" />

<img src=".\image-data-structure\9-3-4.png" alt="image-20230412154940321" style="zoom:67%;" />

### 时间复杂度

<img src=".\image-data-structure\9-3-5.png" alt="image-20230412155007497" style="zoom:80%;" />

<img src=".\image-data-structure\9-3-6.png" alt="image-20230412155300483" style="zoom: 80%;" />

## 直接插入排序

<img src=".\image-data-structure\9-4-1.png" alt="image-20230412160851510" style="zoom: 67%;" />

<img src=".\image-data-structure\9-4-2.png" alt="image-20230412160912273" style="zoom: 67%;" />

<img src=".\image-data-structure\9-4-3.png" alt="image-20230412160942966" style="zoom:67%;" />

<img src=".\image-data-structure\9-4-4.png" alt="image-20230412160958466" style="zoom:67%;" />

<img src=".\image-data-structure\9-4-5.png" alt="image-20230412161015924" style="zoom:67%;" />

<img src=".\image-data-structure\9-4-6.png" alt="image-20230412161029780" style="zoom:67%;" />

### 时间复杂度分析

<img src=".\image-data-structure\9-4-7.png" alt="image-20230412161222165" style="zoom:67%;" />

## 希尔排序

基本思想：

<img src=".\image-data-structure\9-5-1.png" alt="image-20230412172946505" style="zoom:67%;" />

<img src=".\image-data-structure\9-5-2.png" alt="image-20230412173023640" style="zoom:67%;" />

<img src=".\image-data-structure\9-5-3.png" alt="image-20230412173048969" style="zoom:67%;" />

<img src=".\image-data-structure\9-5-4.png" alt="image-20230412173109203" style="zoom:67%;" />

<img src=".\image-data-structure\9-5-5.png" alt="image-20230412173305938" style="zoom:67%;" />

### 复杂度分析

<img src=".\image-data-structure\9-5-6.png" alt="image-20230412173402496" style="zoom:67%;" />

<img src=".\image-data-structure\9-5-7.png" alt="image-20230412173418565" style="zoom:80%;" />

<img src=".\image-data-structure\9-5-10.png" alt="image-20230412173630876" style="zoom:67%;" />

<img src=".\image-data-structure\9-5-9.png" alt="image-20230412173510295" style="zoom:67%;" />

<img src=".\image-data-structure\9-5-8.png" alt="image-20230412173448204" style="zoom:67%;" />



## 堆排序

在简单排序过程中，从待排序的n的记录中选择一个最小的需要比较n-1次。但是，没有把每一次循环比较的结果保存下来，有许多比较（指的是如果这个值不是这一次循环选中的min值，那么下一次循环它还会参与比较）在前一次循环中已经做过了，因而记录的比较次数比较多。

**如果能够在每次选择最小记录的同时，根据比较结果对其他记录做出调整**，那么总体效率就会提高。

堆排序：

<img src=".\image-data-structure\9-6-1.png" alt="image-20230412210559552" style="zoom:67%;" />

<img src=".\image-data-structure\9-6-2.png" alt="image-20230412210623878" style="zoom:67%;" />

<img src=".\image-data-structure\9-6-3.png" alt="image-20230412210654804" style="zoom:67%;" />

<img src=".\image-data-structure\9-6-4.png" alt="image-20230412210712309" style="zoom:67%;" />

### 堆排序算法

<img src=".\image-data-structure\9-6-5.png" alt="image-20230412210753744" style="zoom:67%;" />

<img src=".\image-data-structure\9-6-6.png" alt="image-20230412210814582" style="zoom:67%;" />

<img src=".\image-data-structure\9-6-7.png" alt="image-20230412210848989" style="zoom:67%;" />

### 总代码

<img src=".\image-data-structure\9-6-8.png" alt="image-20230412211314840" style="zoom:80%;" />

**将无序序列调整为堆：**

<img src=".\image-data-structure\9-6-9.png" alt="image-20230412211721295" style="zoom:67%;" />

**选出根结点与最后的结点互换，堆的长度减一，重新调整堆：**

<img src=".\image-data-structure\9-6-10.png" alt="image-20230412213250042" style="zoom:80%;" />

### 时间复杂度分析

<img src=".\image-data-structure\9-6-11.png" alt="image-20230412213353648" style="zoom:80%;" />

<img src=".\image-data-structure\9-6-12.png" alt="image-20230412213410970" style="zoom: 80%;" />

<img src=".\image-data-structure\9-6-13.png" alt="image-20230412213453004" style="zoom:80%;" />

<img src=".\image-data-structure\9-6-14.png" alt="image-20230412213645682" style="zoom: 80%;" />

## 归并排序

将两个有序的序列合并成一个有序序列。

<img src=".\image-data-structure\9-7-1.png" alt="image-20230413113645900" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-2.png" alt="image-20230413113729201" style="zoom:67%;" />

### 代码

<img src=".\image-data-structure\9-7-3.png" alt="image-20230413113756420" style="zoom:67%;" />

递归调用，一直到只剩一个元素就返回

<img src=".\image-data-structure\9-7-4.png" alt="image-20230413113817169" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-5.png" alt="image-20230413113949534" style="zoom:50%;" />

两个有序列表合并算法：

<img src=".\image-data-structure\9-7-6.png" alt="image-20230413114016229" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-7.png" alt="image-20230413114037214" style="zoom:67%;" />

### 时间复杂度分析

<img src=".\image-data-structure\9-7-8.png" alt="image-20230413114301721" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-9.png" alt="image-20230413114603446" style="zoom:67%;" />

### 非递归实现归并排序

<img src=".\image-data-structure\9-7-10.png" alt="image-20230413115942473" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-11.png" alt="image-20230413120001638" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-12.png" alt="image-20230413120033145" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-13.png" alt="image-20230413120055964" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-14.png" alt="image-20230413120236301" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-15.png" alt="image-20230413120304695" style="zoom:67%;" />

<img src=".\image-data-structure\9-7-16.png" alt="image-20230413120351512" style="zoom:80%;" />

## 快速排序

<img src=".\image-data-structure\9-8-1.png" alt="image-20230413150203461" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-2.png" alt="image-20230413150227796" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-7.png" alt="image-20230413151153066" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-3.png" alt="image-20230413150247246" style="zoom:80%;" />

<img src=".\image-data-structure\9-8-4.png" alt="image-20230413150315337" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-5.png" alt="image-20230413150411530" style="zoom:80%;" />

<img src=".\image-data-structure\9-8-6.png" alt="image-20230413150935705" style="zoom: 80%;" />

### 时间复杂度分析

<img src=".\image-data-structure\9-8-8.png" alt="image-20230413151609792" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-9.png" alt="image-20230413151629208" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-10.png" alt="image-20230413151646585" style="zoom:80%;" />

### 优化

#### 优化枢轴的选择

明显前面的快速排序算法第一次选取L[low]作为第一个枢轴的方式不太合理，因为如果第一个值是一个最大值，那么本次排序几乎没有变化，只是把这个最大值放到最后。

因此需要重新调整选择枢轴的方法。

**1.三数取中法：**

即选择三个数字的中间那个数字，三个数都是最大或者最小的概率微乎其微，由于整个序列都是无序状态，因此从左、中、右中选择与随机选择三个数是一样的。

<img src=".\image-data-structure\9-8-11.png" alt="image-20230413152345953" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-12.png" alt="image-20230413152436121" style="zoom:67%;" />

### 优化不必要的交换

即之前的代码中枢轴的位置总是变化，可以将枢轴存在L[0]的位置，这样不用多次交换枢轴的值，直到最终确定枢轴的位置之后再进行交换。

<img src=".\image-data-structure\9-8-13.png" alt="image-20230413152604967" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-14.png" alt="image-20230413152624173" style="zoom:67%;" />

### 优化小数组时的排序方案

对于小数组，由于递归的资源消耗，所以不如直接插入排序（直接插入排序是简单排序里面最好的）。

因此小数组使用直接插入排序即可：

<img src=".\image-data-structure\9-8-15.png" alt="image-20230413152828609" style="zoom:67%;" />

### 优化递归操作

<img src=".\image-data-structure\9-8-16.png" alt="image-20230413153334789" style="zoom:67%;" />

<img src=".\image-data-structure\9-8-17.png" alt="image-20230413153412810" style="zoom:67%;" />

## 总结

<img src=".\image-data-structure\9-9-1.png" alt="image-20230413153502637" style="zoom:67%;" />

<img src=".\image-data-structure\9-9-2.png" alt="image-20230413153523847" style="zoom:67%;" />

<img src=".\image-data-structure\9-9-3.png" alt="image-20230413153648324" style="zoom:67%;" />

<img src=".\image-data-structure\9-9-4.png" alt="image-20230413153748884" style="zoom:67%;" />

<img src=".\image-data-structure\9-9-5.png" alt="image-20230413153823346" style="zoom:67%;" />

<img src=".\image-data-structure\9-9-6.png" alt="image-20230413153906337" style="zoom:67%;" />



